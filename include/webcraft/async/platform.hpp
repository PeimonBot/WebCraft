#pragma once
#include <memory>

// for now for PoC we'll use native libraries
// in the future for a more robust solution, we can use either libuv or libevent
// libevent: https://libevent.org/libevent-book/
// libuv: https://docs.libuv.org/en/v1.x/guide/basics.html

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <winsock2.h>
#include <ws2tcpip.h>
#include <mswsock.h>
#include <windows.h>

#elif defined(__linux__)

#ifndef IO_URING_QUEUE_SIZE
// @brief The size of the io_uring queue. This can be adjusted based on the application's needs.
#define IO_URING_QUEUE_SIZE 256
#endif

#include <unistd.h>
#include <liburing.h>

#elif defined(__APPLE__)

#include <unistd.h>
#include <sys/event.h>
#else
// TODO: figure out what other OS's would be using
#endif

namespace webcraft::async
{
    namespace unsafe
    {
#ifdef _WIN32
#include <windows.h>

        using native_runtime_handle = HANDLE;

#elif defined(__linux__)

        using native_runtime_handle = io_uring;
#elif defined(__APPLE__)

        using native_runtime_handle = int; // kqueue file descriptor
#else
// TODO: figure out what other OS's would be using
#endif

        /// @brief Performs the initialization of the runtime handle based on the platform.
        /// This function is unsafe and should be used with caution. It is intended for internal use only.
        /// @param handle the runtime handle to initialize
        void initialize_runtime_handle(native_runtime_handle &handle);
        /// @brief Performs the destruction of the runtime handle based on the platform.
        /// This function is unsafe and should be used with caution. It is intended for internal use only.
        /// @param handle the runtime handle to destroy
        void destroy_runtime_handle(native_runtime_handle &handle);
    }

    // TODO: document this class
    class runtime_handle
    {
    private:
        unsafe::native_runtime_handle handle;

    public:
        runtime_handle()
        {
            unsafe::initialize_runtime_handle(handle);
        }

        ~runtime_handle()
        {
            unsafe::destroy_runtime_handle(handle);
        }

        const unsafe::native_runtime_handle &get() const
        {
            return handle;
        }

        unsafe::native_runtime_handle *get_ptr()
        {
            return &handle;
        }

        runtime_handle(const runtime_handle &) = delete;
        runtime_handle(runtime_handle &&other) noexcept : handle(std::exchange(other.handle, nullptr)) {}
        runtime_handle &operator=(const runtime_handle &) = delete;
        runtime_handle &operator=(runtime_handle &&other) noexcept
        {
            if (this != &other)
            {
                unsafe::destroy_runtime_handle(handle);
                handle = std::exchange(other.handle, nullptr);
            }
            return *this;
        }
    };

#ifdef _WIN32
#elif defined(__linux__)
    class runtime_event
    {
    private:
#ifdef _WIN32
        OVERLAPPED overlapped = {};
#endif
        std::coroutine_handle<> handle;
        int result = -1;

    public:
        explicit runtime_event(std::coroutine_handle<> h) : handle(h)
        {
#ifdef _WIN32
            ZeroMemory(&overlapped, sizeof(OVERLAPPED));
#endif
        }

#ifdef _WIN32

        OVERLAPPED *get_overlapped() noexcept
        {
            return &overlapped;
        }
#endif

        virtual ~runtime_event() = default;

        void resume(int result) noexcept
        {
            if (handle)
            {
                handle.resume();
            }

            this->result = result;
        }

        constexpr int get_result() const noexcept
        {
            return result;
        }
    };
#elif defined(__APPLE__)
#else
#endif
}