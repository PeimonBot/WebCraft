#pragma once
#include <coroutine>
#include <utility>
#include <concepts>
#include <async/task.h>
#include <functional>

namespace webcraft::async
{

    /// \brief A concept that checks if the type T can be used to be returned from await_suspend
    template <typename T>
    concept suspend_type = std::same_as<T, std::coroutine_handle<>> ||
                           std::derived_from<T, std::coroutine_handle<>> || std::same_as<T, void> || std::same_as<T, bool>;

    /// \brief A concept that checks if the type T is an awaitable type
    template <typename T>
    concept awaitable = requires(T t, std::coroutine_handle<> h) {
        { t.await_ready() } -> std::convertible_to<bool>;
        { t.await_suspend(h) } -> suspend_type;
        { t.await_resume() };
    };

    /// @brief Eager task type that can be used to run asynchronous tasks. No need for spawn then!
    /// @tparam T 
    template <typename T>
    using task = ::async::task<T>;

}