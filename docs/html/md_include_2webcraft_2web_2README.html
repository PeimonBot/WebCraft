<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WebCraft: Web Specification</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">WebCraft<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">An async first C++ framework leveraging powerful features of C++23 built for scale, speed, and ease.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_include_2webcraft_2web_2README.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Web Specification</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md59"></a> </p>
<h1><a class="anchor" id="autotoc_md60"></a>
Introduction</h1>
<p>The backbone of web modules defined here are based off of the async runtime and async io modules.</p>
<p><b>NOTE: You'll notice in this documentation, I'm mentioning the usage of HTTP/3 and UDP protocol even though my current codebase does not have a specification or support for UDP. That would be a newer addition to the framework, an issue for it will be made and either I or (an) open source developer(s) will be working on getting that done with async support.</b></p>
<h1><a class="anchor" id="autotoc_md61"></a>
Implementation</h1>
<h1><a class="anchor" id="autotoc_md62"></a>
namespace webcraft::web::core</h1>
<h2><a class="anchor" id="autotoc_md63"></a>
message</h2>
<div class="fragment"><div class="line"><span class="keyword">using </span>message = std::span&lt;const char&gt;;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md64"></a>
web_read_stream</h2>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>web_read_stream = async_buffered_readable_stream&lt;T, char&gt; &amp;&amp; async_closable_stream&lt;T&gt;;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md65"></a>
web_write_stream</h2>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>web_write_stream = async_buffered_writable_stream&lt;T, char&gt; &amp;&amp; async_closable_stream&lt;T&gt;;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md66"></a>
http_method</h2>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> http_method</div>
<div class="line">{</div>
<div class="line">    GET,</div>
<div class="line">    POST,</div>
<div class="line">    PUT,</div>
<div class="line">    DELETE,</div>
<div class="line">    OPTIONS,</div>
<div class="line">    ...</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md67"></a>
http_response_code</h2>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> http_code</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// </span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// success codes</span></div>
<div class="line">    SUCCESS=200,</div>
<div class="line">    NO_CONTENT=201</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// redirect code</span></div>
<div class="line">    </div>
<div class="line"> </div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md68"></a>
payload_dispatcher</h2>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>payload_dispatcher = <span class="keyword">requires</span>(T t1, T&amp; t2, T&amp;&amp; t3, web_write_stream&amp; stream) {</div>
<div class="line">    { t1(stream) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">    { t2(stream) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">    { t3(stream) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md69"></a>
payload_handler</h2>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Ret&gt;</div>
<div class="line"><span class="keyword">concept </span>payload_handler = <span class="keyword">requires</span>(T t1, T&amp; t2, T&amp;&amp; t3, web_read_stream&amp; stream) {</div>
<div class="line">    { t1(stream) } -&gt; std::same_as&lt;task&lt;Ret&gt;&gt;;</div>
<div class="line">    { t2(stream) } -&gt; std::same_as&lt;task&lt;Ret&gt;&gt;;</div>
<div class="line">    { t3(stream) } -&gt; std::same_as&lt;task&lt;Ret&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md70"></a>
headers namespace</h2>
<p>There will also be a namespace just for the common headers and their values.</p>
<h2><a class="anchor" id="autotoc_md71"></a>
payloads namespace</h2>
<p>There will be a namespace called payloads which has a bunch of functions which help convert to and from C++ friendly objects into <code>payload_dispatcher</code> and <code>payload_handler</code>.</p>
<h1><a class="anchor" id="autotoc_md72"></a>
namespace webcraft::web::connection</h1>
<p>These are the foundational interfaces required to have connections on both the client and server side to be served on TLS or plain text, on TCP or UDP, and on HTTP/1.1, HTTP/2 or HTTP/3.</p>
<h2><a class="anchor" id="autotoc_md73"></a>
connection</h2>
<p>The underlying connection for an HTTP connection is defined by the following primitive:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>connection</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> async_t&lt;size_t&gt; send_data(message data) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> async_t&lt;size_t&gt; recv_data(message data) = 0;</div>
<div class="line">    <span class="keyword">virtual</span> connection_protocol get_protocol() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::optional&lt;ssl_context&gt; get_ssl_context() { <span class="keywordflow">return</span> std::nullopt; };</div>
<div class="line">    <span class="keyword">virtual</span> std::string get_remote_host();</div>
<div class="line">    <span class="keyword">virtual</span> uint16_t get_remote_port();</div>
<div class="line">};</div>
</div><!-- fragment --><p>This underlying connection tells us a couple details about itself: what protocol is it running on, information about the peers host and port, and whether its using tls or not. Apart from that, it also allows us to send and receive data to the peer.</p>
<h2><a class="anchor" id="autotoc_md74"></a>
connection_provider</h2>
<p>Not all connections are created the same way and not all connections have the same properties but we do need a centralized mechanism to provide us with such connections: </p><div class="fragment"><div class="line"><span class="keyword">class </span>connection_provider</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">virtual</span> task&lt;std::shared_ptr&lt;connection&gt;&gt; get_connection() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> std::vector&lt;connection_protocol&gt; get_supported_protocols() = 0;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> tls_supported() = 0; <span class="comment">// will return false until tls is implemented</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> The implementation of this class would take many circumstances into account: Are we the server accepting connections or are we the client creating these connections? are we using TLS or plain text? are we using HTTP/1.1 or HTTP/2 (both TCP based) or HTTP/3 (UDP based)? The connection provider will give us these details and will allow us to acquire a connection, strategy will be depending on the implementation of this interface.</p>
<h3><a class="anchor" id="autotoc_md75"></a>
Usage</h3>
<p>For a <b>client</b> implementing a <code>connection_provider</code>, this would be a specific provider for a particular host and port (localhost:9080, google.com, microsoft.com, ibm.com, etc). Here either new connections are pooled (keep-alive), multiplexed (HTTP/2 or HTTP/3), or spawned (new TCP connection) depending on what protocols the server at that address supports. Similarly <code>get_supported_protocols</code> and <code>tls_supported</code> are based on what the server supports.</p>
<p>For a <b>server</b> implementing a <code>connection_provider</code>, this provider would represent the provider of the server. <code>get_connection</code> receives a connection, whether its a multiplexed connection, pooled connection, new connection, or a QUIC connection. <code>get_supported_protocols</code> is based on what the "server" supports (and is also limited by framework features - can't do HTTP/3 if UDP support is not existant). <code>tls_supported</code> is based on whether the server using this provider has enabled TLS.</p>
<h2><a class="anchor" id="autotoc_md76"></a>
connection_protocol</h2>
<p>The definition of connection protocol is shown here. It lists out the types of HTTP protocols which will be used. </p><div class="fragment"><div class="line"><span class="keyword">enum class</span> connection_protocol</div>
<div class="line">{</div>
<div class="line">    HTTP_1_0,</div>
<div class="line">    HTTP_1_1,</div>
<div class="line">    HTTP_2,</div>
<div class="line">    HTTP_3</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md77"></a>
namespace webcraft::web::client</h1>
<p>The web client API that we provide is inspired by multiple other languages implementation including JS implementations (<code>fetch</code>, <code>axios</code>, <code>XMLHTTPRequest</code>, <code>WebSocket</code>, <code>EventObject</code>), Java (<code>HTTPClient</code>, <code>WebClient</code>, <code>HTTPUrlConnection</code>), and C# (<code>WebClient</code>, <code>HTTPClient</code>). This API will implement the connection provider to supply connections to the client. As such, there should be ideally one <code>web_client</code> per application since it will pool and multiplex connections.</p>
<h2><a class="anchor" id="autotoc_md78"></a>
web_client</h2>
<p>The definition is below. Seems pretty lean right? <code>web_client</code> provides the mechanism to create a connection using <code>web_connection_builder</code> and its possible to attach or create a <code>web_connection_builder</code> via constructor passing in a web_client. Just following fluent pattern:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>web_client</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> set_ssl_trust_store(ssl_trust_store store); <span class="comment">// sets trust store - will throw tls_not_implemented_error until tls is implemented</span></div>
<div class="line">    ssl_trust_store&amp; get_trust_store() <span class="comment">// gets the trust store - will throw tls_not_implemented_error until tls is implemented</span></div>
<div class="line"> </div>
<div class="line">    task&lt;<span class="keywordtype">void</span>&gt; close(); <span class="comment">// closes any outstanding connections that are kept alive</span></div>
<div class="line"> </div>
<div class="line">    web_connection_builder connect();</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md79"></a>
web_connection_builder</h2>
<p>The definition is below.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>web_connection_builder</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span>web_client;</div>
<div class="line"> </div>
<div class="line">    web_connection_builder(web_client&amp; ref);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// builders</span></div>
<div class="line">    web_connection_builder&amp; path(uri target_uri);</div>
<div class="line">    web_connection_builder&amp; method(http_method method); <span class="comment">// changes to this have no effect on websocket based connections</span></div>
<div class="line">    web_connection_builder&amp; headers(std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; headers);</div>
<div class="line">    web_connection_builder&amp; header(std::string name, std::string value);</div>
<div class="line">    web_connection_builder&amp; proxy(uri proxy_uri);</div>
<div class="line">    web_connection_builder&amp; allow_redirects(<span class="keywordtype">bool</span> allow = <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    task&lt;web_client_connection&gt; request_raw();</div>
<div class="line">    task&lt;web_socket_connection&gt; websocket(); <span class="comment">// don&#39;t fill in `method` since websockets on HTTP/1.1 and HTTP/2 &amp; 3 are different</span></div>
<div class="line">    task&lt;web_response&gt; send(payload_dispatcher <span class="keyword">auto</span>&amp;&amp; sender);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Through this class, we can build composable builders to spawn templated connections. We can specify the path, the method, the headers, the proxy, redirect handling, and continue building until we are ready to make the connection. We have 3 options at this point.</p><ol type="1">
<li>We can directly handle the connection afterwards and get ourselves a <code>web_client_connection</code>.</li>
<li>We can create a <code>web_socket_connection</code>.</li>
<li>We can send a payload by providing a <code>payload_dispatcher</code> and receiving a <code>web_response</code>.</li>
</ol>
<p>Through Option 1, we can handle the read and write streams how we want and gain more control over how the connection is actually going to be handled. This is great if you want to do some ping ponging data processing like what gRPC does on HTTP/2 (will be kinda hacky on HTTP/1.1 since <b>technically</b> HTTP/1.1 does not support ping-ponging) or if you feel that the <code>send</code> function isn't good enough (which it probably is for non ping-pong related exchanges).</p>
<p>Through Option 2, we can create a websocket client at the given addresses. Note that the path is recommended to start with "ws://" and "wss://" and not with "http://" or "https://" (though I'll be forgiving and rewrite that http part to ws). Also note that whatever you set the method to... it doesn't matter, if its HTTP/1.1 it will send a GET request with an Upgrade header, if its HTTP/2 it will send a CONNECT request and set some websocket headers. Any headers set by the client which are "websocket" headers will be overwritten, anything which is not websocket related will be kept.</p>
<p>Through Option 3, we can have <code>fetch</code> or <code>axios</code> or <code>HTTPClient</code> like syntax for sending requests. You can create a function or a class which obeys the payload dispatcher and reference it or you can use some of the existing ones in the <code>payloads</code> namespace described in the <code>webcraft::web::core</code> section</p>
<h2><a class="anchor" id="autotoc_md80"></a>
web_response_base</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>web_response_base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::optional&lt;std::string&gt; get_response_header(std::string name);</div>
<div class="line">    std::vector&lt;std::string&gt; get_response_headers(std::string name);</div>
<div class="line">    std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; get_response_headers();</div>
<div class="line"> </div>
<div class="line">    http_response_code get_response_code();</div>
<div class="line">    http_method get_method();</div>
<div class="line">    connection_protocol get_protocol();</div>
<div class="line">    std::string get_remote_host();</div>
<div class="line">    uint16_t get_remote_port();</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md81"></a>
web_client_connection</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>web_client_connection : <span class="keyword">public</span> web_response_base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    web_read_stream <span class="keyword">auto</span>&amp; get_read_stream();</div>
<div class="line">    web_write_stream <span class="keyword">auto</span>&amp; get_write_stream();</div>
<div class="line">    task&lt;void&gt; close();</div>
<div class="line">};</div>
</div><!-- fragment --><p>Represents a raw client connection. Allows the user to manage input and output stream processing directly.</p>
<h2><a class="anchor" id="autotoc_md82"></a>
web_socket_connection</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>web_socket_connection : <span class="keyword">public</span> web_response_base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    web_read_stream&amp; get_read_stream();</div>
<div class="line">    web_write_stream&amp; get_write_stream();</div>
<div class="line">    task&lt;void&gt; close();</div>
<div class="line">};</div>
</div><!-- fragment --><p>Represents a websocket connection. It looks like its the same as <code>web_client_connection</code> but its actually establishing an HTTP connection under the hood and then running the WebSocket protocol on top of it.</p>
<h2><a class="anchor" id="autotoc_md83"></a>
web_response</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>web_response : <span class="keyword">public</span> web_response_base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    task&lt;T&gt; get_payload(payload_handler&lt;T&gt; <span class="keyword">auto</span>&amp;&amp; handler);</div>
<div class="line"> </div>
<div class="line">    task&lt;void&gt; close();</div>
<div class="line">};</div>
</div><!-- fragment --><p>Allows us to get the payload. You can create a function or a class which obeys the payload handler and reference it or you can use some of the existing ones in the <code>payloads</code> namespace described in the <code>webcraft::web::core</code> section.</p>
<h1><a class="anchor" id="autotoc_md84"></a>
namespace webcraft::web::server</h1>
<p>Web Clients are fun and necessary but clients are supposed to connect to something and thats what this framework helping you craft, web servers. So lets get into the real deal.</p>
<h2><a class="anchor" id="autotoc_md85"></a>
web_server</h2>
<p>The web server implementation is defined as follows: </p><div class="fragment"><div class="line"><span class="keyword">class </span>web_server</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// server properties</span></div>
<div class="line">    <span class="keywordtype">bool</span> add_supported_protocol(connection_protocol protocol);</div>
<div class="line">    <span class="keywordtype">void</span> set_ssl_context(ssl_context ctx);</div>
<div class="line">    <span class="keywordtype">void</span> set_property(std::string key, std::string value);</div>
<div class="line">    <span class="comment">// server runtime management functions</span></div>
<div class="line">    task&lt;void&gt; start();</div>
<div class="line">    fire_and_forget_task shutdown();</div>
<div class="line">    task&lt;void&gt; run_until_stopped(std::stop_token token);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// lifetime hooks</span></div>
<div class="line">    <span class="keywordtype">void</span> on_started(server_state_cb <span class="keyword">auto</span>&amp;&amp; cb);</div>
<div class="line">    <span class="keywordtype">void</span> on_shutdown(server_state_cb <span class="keyword">auto</span>&amp;&amp; cb);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// routing</span></div>
<div class="line">    web_route&amp; route(std::vector&lt;std::string&gt; routes);</div>
<div class="line">};</div>
</div><!-- fragment --><p>It supports setting initialization proeprties (constants defined in the namespace like "http.port" and "https.port" and "host"). It also allows asynchronously starting the program (start the server and have it run in the background). Once the server is started we can be notified by setting <code>on_started</code> callback. We can signal shutdown using the <code>shutdown</code> function and once our server is shutdown, we can get a notification on the <code>on_shutdown</code> callback. Another approach would be to have a stop source and have it run until the stop_token is fired (callbacks will still be fired, <code>shutdown</code> signal takes more priority than stop token passed in). To perform routing and serving, we can use the <code>route</code> function to provide us a representation of what happens in that route.</p>
<h2><a class="anchor" id="autotoc_md86"></a>
server_state_cb &amp; web_server_context_manager</h2>
<p>Our callbacks look like this. We are implementing bare minimum CDI since languages like JS &amp; Python have features where in the middleware they can "attach" information to the request object. While you can bypass this by setting some special header internally and checking if thats good, this would be better to manage "server" scoped logic.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>server_state_cb = <span class="keyword">requires</span>(T t1, T&amp; t2, T&amp;&amp; t3, web_server_context_manager manager) {</div>
<div class="line">    { t1(manager) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">    { t2(manager) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">    { t3(manager) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>web_server_context_manager</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    T get(std::string item);</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keywordtype">void</span> set(std::string item, T value);</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md87"></a>
web_route &amp; error_handler_route &amp; cors_config</h2>
<p>The web route represents the your actual route. Middleware can be handled directly using the <code>use</code> function. You can also perform raw request handling (non websocket ping-ponging or custom protocol ontop of HTTP like gRPC) in the <code>use</code> function (I'd recommend you to do so here).</p>
<p>The route will be continoud to be "chained" until the user chooses to have it handle HTTP connections or WebSocket connections which it will then fallback on an error_handler_route. This error handler route can pass in an <code>error_handler_cb</code> in which if some exception happens along the chain, this route is the first responder (and our internal server stuff being the next).</p>
<p>Lastly, all API should be able to be visible on the brwoser side so CORS config has been added.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>web_route</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    web_route&amp; use(web_route_handler_cb handler); <span class="comment">// for middleware or raw connections</span></div>
<div class="line">    web_route&amp; cors(cors_config config); <span class="comment">// CORS handler</span></div>
<div class="line">    error_handler_route handle_http_method(http_method method, http_route_handler_cb handler); <span class="comment">// for basic http connections</span></div>
<div class="line">    error_handler_route handle_websocket(web_socket_handler_cb handler); <span class="comment">// for websocket connections</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>error_handler_route</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> on_error(error_handler <span class="keyword">auto</span>&amp;&amp; handler);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>cors_config</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;http_method&gt; allowed_methods;</div>
<div class="line">    std::vector&lt;std::string&gt; allowed_origins;</div>
<div class="line">    std::vector&lt;std::string&gt; allowed_headers;</div>
<div class="line">    <span class="keywordtype">bool</span> allow_credentials;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md88"></a>
web_route_handler &amp; http_route_handler &amp; web_socket_handler &amp; error_handler_cb</h2>
<p>Our callbacks. I find its kind of self explainatory. <code>web_route_handler</code>, <code>web_socket_handler</code>, <code>error_handler_cb</code> both accept a connection scoped context, a request which provides a readable stream, and a response which provides a writable stream. <code>web_route_handler</code> also provides a <code>next_function</code> if one wants to move to the next chain of events. <code>http_route_handler</code> is different, it accepts a request which provides a payload and returns a response object. <code>error_handler_cb</code> provides an exception pointer object.</p>
<div class="fragment"><div class="line"><span class="keyword">using </span>next_function = std::function&lt;task&lt;void&gt;()&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>web_route_handler_cb = <span class="keyword">requires</span>(T t1, T&amp; t2, T&amp;&amp; t3, web_server_context_view view, web_request req, web_response resp, next_function func)</div>
<div class="line">{</div>
<div class="line">    { t1(view, req, resp, func) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">    { t2(view, req, resp, func) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">    { t3(view, req, resp, func) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>http_route_handler_cb = <span class="keyword">requires</span>(T t1, T&amp; t2, T&amp;&amp; t3, web_server_context_view view, http_request req)</div>
<div class="line">{</div>
<div class="line">    { t1(view, req, resp) } -&gt; std::same_as&lt;task&lt;http_response&gt;&gt;;</div>
<div class="line">    { t2(view, req, resp) } -&gt; std::same_as&lt;task&lt;http_response&gt;&gt;;</div>
<div class="line">    { t3(view, req, resp) } -&gt; std::same_as&lt;task&lt;http_response&gt;&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>web_socket_handler_cb = <span class="keyword">requires</span>(T t1, T&amp; t2, T&amp;&amp; t3, web_server_context_view view, web_socket_request req, web_socket_response resp)</div>
<div class="line">{</div>
<div class="line">    { t1(view, req, resp) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">    { t2(view, req, resp) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">    { t3(view, req, resp) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>error_handler_cb = <span class="keyword">requires</span>(T t1, T&amp; t2, T&amp;&amp; t3, std::exception_ptr ptr, web_server_context_view view, web_request req, web_response resp)</div>
<div class="line">{</div>
<div class="line">    { t1(ptr, view, req, resp) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">    { t2(ptr, view, req, resp) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">    { t3(ptr, view, req, resp) } -&gt; std::same_as&lt;task&lt;void&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md89"></a>
web_server_context_view</h2>
<p>This is how connection scoped CDI looks like.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>web_server_context_view</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    T get_global(std::string item);</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keywordtype">void</span> set_global(std::string item, T value);</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    T get_local(std::string item);</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keywordtype">void</span> set_local(std::string item, T value);</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md90"></a>
Web Requests</h2>
<p>This is the definition for the base of all web requests.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>web_request_base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    std::unordered_map&lt;std::string, std::string&gt; get_path_params();</div>
<div class="line">    std::optional&lt;std::string&gt; get_path_param(std::string param);</div>
<div class="line"> </div>
<div class="line">    std::unordered_map&lt;std::string, std::string&gt; get_query_params();</div>
<div class="line">    std::optional&lt;std::string&gt; get_query_param(std::string param);</div>
<div class="line"> </div>
<div class="line">    std::string get_path();</div>
<div class="line">    std::string get_http_method();</div>
<div class="line"> </div>
<div class="line">    std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; get_headers();</div>
<div class="line">    std::vector&lt;std::string&gt; get_headers(std::string name);</div>
<div class="line">    std::optional&lt;std::string&gt; get_headers(std::string name);</div>
<div class="line">};</div>
</div><!-- fragment --><p>These are the individual request types.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>web_request : <span class="keyword">public</span> web_request_base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    web_read_stream <span class="keyword">auto</span>&amp; get_read_stream();</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span>web_socket_request : <span class="keyword">public</span> web_request_base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    web_read_stream <span class="keyword">auto</span>&amp; get_read_stream();</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span>http_request : <span class="keyword">public</span> web_request_base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    task&lt;T&gt; get_payload(payload_handler&lt;T&gt; <span class="keyword">auto</span>&amp;&amp; handler);</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md91"></a>
Web Responses</h2>
<p>This is the definition for the base of all web responses.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>web_response_base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    task&lt;void&gt; set_status_code(http_code code);</div>
<div class="line">    task&lt;void&gt; set_header(std::string name, std::string value);</div>
<div class="line">};</div>
</div><!-- fragment --><p>These are the individual response types.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>web_response : <span class="keyword">public</span> web_response_base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    web_write_stream <span class="keyword">auto</span>&amp; get_write_stream();</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span>web_socket_response : <span class="keyword">public</span> web_response_base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    web_write_stream <span class="keyword">auto</span>&amp; get_write_stream();</div>
<div class="line">};</div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keyword">class </span>http_response</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span>web_server;</div>
<div class="line"> </div>
<div class="line">    http_response&amp; set_response_code(http_code code);</div>
<div class="line">    http_response&amp; set_header(std::string name, std::string header);</div>
<div class="line">    http_response&amp; set_headers(std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; headers);</div>
<div class="line">    http_response&amp; set_payload(payload_dispatcher <span class="keyword">auto</span>&amp;&amp; dispatcher);</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md92"></a>
namespace webcraft::web::secure</h1>
<p>Coming Soon.... will need to add OpenSSL into the mix.</p>
<h1><a class="anchor" id="autotoc_md93"></a>
Resources</h1>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Resources_and_specifications">https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Resources_and_specifications</a></li>
<li><a href="https://httpwg.org/specs/">https://httpwg.org/specs/</a></li>
<li><a href="https://websocket.org/guides/websocket-protocol/">https://websocket.org/guides/websocket-protocol/</a></li>
<li><a href="https://websockets.spec.whatwg.org/">https://websockets.spec.whatwg.org/</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers</a></li>
<li><a href="https://www.rfc-editor.org/rfc/rfc7118.html">https://www.rfc-editor.org/rfc/rfc7118.html</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
