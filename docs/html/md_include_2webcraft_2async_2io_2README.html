<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WebCraft: Asynchronous I/O Implemented in WebCraft</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">WebCraft<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">An async first C++ framework leveraging powerful features of C++23 built for scale, speed, and ease.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Asynchronous I/O Implemented in WebCraft</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> This readme will go over how WebCraft handles <b>Asynchronous I/O</b> powered with the latest C++ coroutine features.</p>
<p>Table of Contents:</p>
<ol type="1">
<li>Async Streams</li>
<li>Async Readable Stream Adaptors</li>
<li>Async File I/O</li>
<li>Async Socket I/O</li>
</ol>
<h1><a class="anchor" id="autotoc_md1"></a>
Async Streams</h1>
<p>Async I/O in webcraft is implemented using the concept of Streams (similar to Java Streams API and Java Input and Output Streams). There are 2 types of async streams defined in here: the async readable stream and async writable stream.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Async readable streams</h2>
<p>The definition of it is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">concept </span>async_readable_stream = std::is_move_constructible_v&lt;Derived&gt; &amp;&amp; <span class="keyword">requires</span>(Derived &amp;stream) {</div>
<div class="line">    { stream.recv() } -&gt; std::same_as&lt;task&lt;std::optional&lt;R&gt;&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The any type which models <code>async_readable_stream&lt;R&gt;</code> must have a function <code>recv()</code> which takes in no arguments and returns a <code>task&lt;std::optional&lt;R&gt;&gt;</code>. Here <code>R</code> represents the type of value streamed to the client. The end of the stream is denoted when the result of the task is a <code>std::nullopt</code> which subsequent calls to <code>recv()</code> will result in.</p>
<p>There is also a buffered variant as shown below for streams which implement buffering internally:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">concept </span>async_buffered_readable_stream = async_readable_stream&lt;Derived, R&gt; &amp;&amp; <span class="keyword">requires</span>(Derived &amp;stream, std::span&lt;R&gt; buffer) {</div>
<div class="line">    { stream.recv(buffer) } -&gt; std::same_as&lt;task&lt;std::size_t&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The buffered variant allows you to send in multiple objects at once into the stream. Internally, the regular <code>recv()</code> variant will either call the buffered variant with size of 1 or it will internally buffer it so if the values already exist in the queue, it only needs to pop it from there instead of waiting.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Async writable streams</h2>
<p>The definition of it is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">concept </span>async_writable_stream = std::is_move_constructible_v&lt;Derived&gt; &amp;&amp; <span class="keyword">requires</span>(Derived &amp;stream, R &amp;&amp;value) {</div>
<div class="line">    { stream.send(std::forward&lt;R&gt;(value)) } -&gt; std::same_as&lt;task&lt;bool&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Any type which models <code>async_writable_stream&lt;R&gt;</code> must have a function <code>send(R&amp;&amp; )</code> which takes in an lvalue for R (to be moved into the stream) and returns a <code>task&lt;bool&gt;</code> which indicates that the value has been written or not.</p>
<p>There is also a buffered variant which allows you to write multiple objects at once (better for batching).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">concept </span>async_buffered_writable_stream = async_writable_stream&lt;Derived, R&gt; &amp;&amp; <span class="keyword">requires</span>(Derived &amp;stream, std::span&lt;R&gt; buffer) {</div>
<div class="line">    { stream.send(buffer) } -&gt; std::same_as&lt;task&lt;size_t&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This version accepts a span of values which will be written to the stream.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Async stream helpers</h2>
<p>For those who do want to read and write multiple values without knowing whether the implementation provides buffering or not, we've created some helper functions:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, async_readable_stream&lt;R&gt; RStream, <span class="keywordtype">size_t</span> BufferSize&gt;</div>
<div class="line">task&lt;std::size_t&gt; recv(RStream &amp;stream, std::span&lt;R, BufferSize&gt; buffer);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, async_writable_stream&lt;R&gt; WStream, <span class="keywordtype">size_t</span> BufferSize&gt;</div>
<div class="line">task&lt;size_t&gt; send(WStream &amp;stream, std::span&lt;R, BufferSize&gt; buffer);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, async_readable_stream&lt;R&gt; RStream&gt;</div>
<div class="line">async_generator&lt;R&gt; to_async_generator(RStream &amp;&amp;stream);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;</div>
<div class="line">async_readable_stream&lt;R&gt; <span class="keyword">auto</span> to_readable_stream(async_generator&lt;R&gt; &amp;&amp;gen);</div>
</div><!-- fragment --><p>The batched <code>recv()</code> and <code>send()</code> call the buffered streams variants of <code>recv()</code> and <code>send()</code> if a buffered stream is passed, otherwise it will call enough <code>recv()</code> and <code>send()</code> from the non buffered variants until the span is filled or until we can't read or write anymore from the stream.</p>
<p>The conversion to and from async generators are added for readable streams since it would be really nice to be able to do something like this:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> fn = [](<span class="keywordtype">size_t</span> limit) -&gt; async_generator&lt;int&gt; {</div>
<div class="line">    <span class="keywordtype">size_t</span> count = 0;</div>
<div class="line">    <span class="keywordflow">while</span> (count &lt; limit) {</div>
<div class="line">        <span class="keyword">co_await</span> sleep(200ms);</div>
<div class="line">        <span class="keyword">co_yield</span> count++;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> rstream = <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#a65fdb2f3bc3e4af76fe30526dcb1e4b1">to_readable_stream</a>(fn(10));</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">auto</span> opt = <span class="keyword">co_await</span> rstream.next()) {</div>
<div class="line">    handle(opt.value());</div>
<div class="line">}</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_html_a65fdb2f3bc3e4af76fe30526dcb1e4b1"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io.html#a65fdb2f3bc3e4af76fe30526dcb1e4b1">webcraft::async::io::to_readable_stream</a></div><div class="ttdeci">async_readable_stream&lt; R &gt; auto to_readable_stream(async_generator&lt; R &gt; &amp;&amp;gen)</div><div class="ttdef"><b>Definition</b> core.hpp:126</div></div>
</div><!-- fragment --><p>This will allow us to add a powerful set of adaptors onto async streams similar to the adaptors added with the ranges library onto iterables. From this, we can build powerful stream processing and pub/sub systems which can do a variety of processing without ever requiring us to have to manually process the stream ourselves</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Channels</h2>
<p>Channels are a mechanism to transfer data from a publisher to a subscriber. The model that we have implemented our channels is through MPSC (multiple publishers to a single consumer - since it only makes sense to deal with one event at a time). You can create an MPSC channel as shown below (NOTE: you have to specify data type of channel otherwise what data will you be sending over in the first place):</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [rstream, wstream] = make_mpsc_channel&lt;int&gt;();</div>
</div><!-- fragment --><p>The type of <code>rstream</code> satisfies <code>async_readable_stream</code> and the type of <code>wstream</code> satisfies <code>async_writable_stream</code>. This effectively is an asynchronous pipe. Concurrency here is not required to be a concern since whenever the "send()" on the writeable stream occurs, we resume the existing read.</p>
<p><b>NOTE: DO NOT TRY AND PIPE <code>rstream</code> into <code>wstream</code> as it will cause an infinite loop (more so a stackoverflow exception) since all values received from read will be sent into write which will be sent into read and you get the rest.</b></p>
<p>Working with this becomes really useful as you can build highly scalable Publisher Subscriber Applications based off of channels as your data sending medium. Most microservices use this message queues which internally uses channels since it makes working with event streams a lot easier. I myself am planning on using channels for managing async socket I/O and async file I/O.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Async Readable Stream Adaptors</h1>
<p>Stream's aren't really useful by themselves. Most of the time, we want to turn our raw data into something useful to then deal with it. This is the idea of a <b>stream adaptor</b>. We take a readable stream of one data type, then we apply some kind of operation on it (mapping, filtering, transforming), then we get a stream of another data type, something more useful to deal with.</p>
<p>Here is an example:</p>
<p>Suppose, we want to group the students into a map where we assign a lesson grade (A for 80-100, B for 70-80, C for 60-70, and D for 50-60) as showing and get rid of any students which are failing and have the students sorted in each grouping in order:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>student {</div>
<div class="line">    std::string name;</div>
<div class="line">    std::vector&lt;double&gt; marks;</div>
<div class="line">    std::string grade;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The non-adaptor based solution would look something like this:</p>
<div class="fragment"><div class="line">task&lt;std::unordered_map&lt;std::string, std::vector&lt;student&gt;&gt;&gt; get_student_grade_groupings(async_readable_stream&lt;student&gt; students) {</div>
<div class="line">    std::unordered_map&lt;std::string, student&gt; map;</div>
<div class="line">    map[<span class="stringliteral">&quot;A&quot;</span>] = {};</div>
<div class="line">    map[<span class="stringliteral">&quot;B&quot;</span>] = {};</div>
<div class="line">    <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a467323c557b8245b25c7cc5c6cd28e22">map</a>[<span class="stringliteral">&quot;C&quot;</span>] = {};</div>
<div class="line">    <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a467323c557b8245b25c7cc5c6cd28e22">map</a>[<span class="stringliteral">&quot;D&quot;</span>] = {};</div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">auto</span> st = <span class="keyword">co_await</span> students)</div>
<div class="line">    {</div>
<div class="line">        std::vector&lt;double&gt; marks = st.marks;</div>
<div class="line">        <span class="keywordtype">double</span> sum_of_marks = std::accumulate(marks.begin(), marks.end(), 0.0));</div>
<div class="line">        <span class="keywordtype">size_t</span> num_of_marks = marks.size();</div>
<div class="line">        <span class="keywordtype">double</span> average = sum_of_marks / num_of_marks;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (average &gt;= 80.0) {</div>
<div class="line">            <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a467323c557b8245b25c7cc5c6cd28e22">map</a>[<span class="stringliteral">&quot;A&quot;</span>].push_back(*st);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (average &gt;= 70.0) {</div>
<div class="line">            <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a467323c557b8245b25c7cc5c6cd28e22">map</a>[<span class="stringliteral">&quot;B&quot;</span>].push_back(*st);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (average &gt;= 60.0) {</div>
<div class="line">            <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a467323c557b8245b25c7cc5c6cd28e22">map</a>[<span class="stringliteral">&quot;C&quot;</span>].push_back(*st);</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (average &gt;= 50.0) {</div>
<div class="line">            <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a467323c557b8245b25c7cc5c6cd28e22">map</a>[<span class="stringliteral">&quot;D&quot;</span>].push_back(*st);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::sort(map[<span class="stringliteral">&quot;A&quot;</span>]);</div>
<div class="line">    std::sort(map[<span class="stringliteral">&quot;B&quot;</span>]);</div>
<div class="line">    std::sort(map[<span class="stringliteral">&quot;C&quot;</span>]);</div>
<div class="line">    std::sort(map[<span class="stringliteral">&quot;D&quot;</span>]);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a467323c557b8245b25c7cc5c6cd28e22">map</a>;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_a467323c557b8245b25c7cc5c6cd28e22"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a467323c557b8245b25c7cc5c6cd28e22">webcraft::async::io::adaptors::map</a></div><div class="ttdeci">auto map(Func &amp;&amp;fn)</div><div class="ttdef"><b>Definition</b> adaptors.hpp:71</div></div>
</div><!-- fragment --><p>The adaptor based solution would be as follows:</p>
<div class="fragment"><div class="line">std::string average_to_grade(<span class="keywordtype">double</span> average) {</div>
<div class="line">    <span class="keywordflow">if</span> (average &gt;= 80.0) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;A&quot;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (average &gt;= 70.0) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;B&quot;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (average &gt;= 60.0) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;C&quot;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (average &gt;= 50) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;D&quot;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;F&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> get_average(student st) {</div>
<div class="line">    std::vector&lt;double&gt; marks = st.marks;</div>
<div class="line">    <span class="keywordtype">double</span> sum_of_marks = std::accumulate(marks.begin(), marks.end(), 0.0));</div>
<div class="line">    <span class="keywordtype">size_t</span> num_of_marks = marks.size();</div>
<div class="line">    <span class="keywordtype">double</span> average = sum_of_marks / num_of_marks;</div>
<div class="line">    <span class="keywordflow">return</span> average;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">task&lt;std::unordered_map&lt;std::string, std::vector&lt;student&gt;&gt;&gt; get_student_grade_groupings(async_readable_stream&lt;student&gt; students) {</div>
<div class="line">    <span class="keywordflow">return</span> students | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#adda76c1251d855604fa6c9f4b752de2c">filter</a>([](<span class="keyword">auto</span> st) {</div>
<div class="line">        <span class="keywordflow">return</span> get_average(st) &gt;= 50;</div>
<div class="line">    }) | sorted([](<span class="keyword">auto</span> pair) {</div>
<div class="line">        <span class="keywordflow">return</span> pair.key; </div>
<div class="line">    }) | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors_1_1collectors.html#a2e67493f2e10fee623eb18b43d02ea71">group_by</a>([](<span class="keyword">auto</span> st) {</div>
<div class="line">        <span class="keywordflow">return</span> average_to_grade(get_average(st));</div>
<div class="line">    });</div>
<div class="line">}</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_1_1collectors_html_a2e67493f2e10fee623eb18b43d02ea71"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors_1_1collectors.html#a2e67493f2e10fee623eb18b43d02ea71">webcraft::async::io::adaptors::collectors::group_by</a></div><div class="ttdeci">auto group_by(std::function&lt; KeyType(const T &amp;)&gt; key_function)</div><div class="ttdef"><b>Definition</b> adaptors.hpp:351</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_adda76c1251d855604fa6c9f4b752de2c"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#adda76c1251d855604fa6c9f4b752de2c">webcraft::async::io::adaptors::filter</a></div><div class="ttdeci">auto filter(Func &amp;&amp;predicate)</div><div class="ttdef"><b>Definition</b> adaptors.hpp:137</div></div>
</div><!-- fragment --><p>This is just one example which would greatly reduce the amount of code and logic involved to write a program. There are many other uses for having async streams including when dealing with pub/sub streams.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Some of the adaptors have already been implemented in this framework:</h2>
<p>All stream adaptors have to inherit the <code>async_readable_stream_adaptor</code>. The definition of it is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>async_readable_stream_adaptor</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">auto</span> operator|(async_readable_stream&lt;T&gt; <span class="keyword">auto</span> &amp;&amp;stream, Derived &amp;adaptor)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::invoke(adaptor, std::move(stream));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">auto</span> operator|(async_readable_stream&lt;T&gt; <span class="keyword">auto</span> &amp;&amp;stream, Derived &amp;&amp;adaptor)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::invoke(std::move(adaptor), std::forward&lt;<span class="keyword">decltype</span>(stream)&gt;(stream));</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
Transform adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InType, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> transform(Func &amp;&amp;fn) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this you'll be able transform the existing async_readable_stream to another async_readable_stream. The function that is passed has to be of signature <code>async_generator&lt;OutType&gt;(async_generator&lt;InType&gt;)</code> where <code>OutType</code> is the transformed readable stream passed from the <code>transform</code> function. Some examples of this are shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream stream({1,2,3,4,5});</div>
<div class="line"> </div>
<div class="line">async_readable_stream&lt;std::string&gt; <span class="keyword">auto</span> new_stream = stream | transform([](async_generator&lt;int&gt; gen) {</div>
<div class="line">    <a class="code hl_define" href="async__generator_8hpp.html#a4d7b3885bfafff1b24249b43416127d2">for_each_async</a>(value, gen, {</div>
<div class="line">        <span class="keyword">co_yield</span> std::to_string(value);</div>
<div class="line">        <span class="keyword">co_yield</span> std::to_string(value * 2);</div>
<div class="line">    });</div>
<div class="line">});</div>
<div class="line"><span class="comment">// the value of this is [&quot;1&quot;, &quot;2&quot;, &quot;2&quot;, &quot;4&quot;, &quot;3&quot;, &quot;6&quot;, &quot;4&quot;, &quot;8&quot;, &quot;5&quot;, &quot;10&quot;]</span></div>
<div class="ttc" id="aasync__generator_8hpp_html_a4d7b3885bfafff1b24249b43416127d2"><div class="ttname"><a href="async__generator_8hpp.html#a4d7b3885bfafff1b24249b43416127d2">for_each_async</a></div><div class="ttdeci">#define for_each_async(value, gen, code)</div><div class="ttdef"><b>Definition</b> async_generator.hpp:422</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md9"></a>
Map adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InType, <span class="keyword">typename</span> Func, <span class="keyword">typename</span> OutType = std::invoke_result_t&lt;Func, InType&gt;&gt;</div>
<div class="line"><span class="keyword">auto</span> map(Func &amp;&amp;fn) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you create a new readable stream which has the values from the old stream mapped using the function passed. An example of this is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream stream({1,2,3,4,5});</div>
<div class="line"> </div>
<div class="line">async_readable_stream&lt;std::string&gt; <span class="keyword">auto</span> new_stream = stream | map([](<span class="keywordtype">int</span> value) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(value);</div>
<div class="line">});</div>
<div class="line"><span class="comment">// the value of this is [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md10"></a>
Pipe adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span> std::is_copy_assignable_v&lt;T&gt;</div>
<div class="line"><span class="keyword">auto</span> pipe(async_writable_stream&lt;T&gt; <span class="keyword">auto</span> &amp;str) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you create a new readable stream on which when read, also forwards the read value into the writable stream provided. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; rstream({1,2,3,4,5});</div>
<div class="line">mock_writable_stream&lt;int&gt; wstream;</div>
<div class="line"> </div>
<div class="line">async_readable_stream&lt;int&gt; <span class="keyword">auto</span> new_stream = rstream | pipe(wstream);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">auto</span> opt = <span class="keyword">co_await</span> new_stream.recv()) {</div>
<div class="line">    assert(wstream.received_value(*opt));</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
Filter adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> filter(Func &amp;&amp;predicate) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to filter out values in the streams which you do want to retain. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line">async_readable_stream&lt;int&gt; <span class="keyword">auto</span> new_stream = stream | filter([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; });</div>
<div class="line"><span class="comment">// streams returned is [2,4]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md12"></a>
Limit adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> limit(<span class="keywordtype">size_t</span> size) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to limit the amount of values sent through the stream. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line">async_readable_stream&lt;int&gt; <span class="keyword">auto</span> new_stream = stream | limit(3);</div>
<div class="line"><span class="comment">// streams returned is [1,2,3]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md13"></a>
Skip adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> skip(<span class="keywordtype">size_t</span> size) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to skip the amount of values sent through the stream. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line">async_readable_stream&lt;int&gt; <span class="keyword">auto</span> new_stream = stream | skip(2);</div>
<div class="line"><span class="comment">// streams returned is [3,4,5]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14"></a>
Take while adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> take_while(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to take the values sent through the stream while the predicate defined by <code>Func</code> yields true. <code>Func</code> must have the following type signature <code>bool(const T&amp;)</code>. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line">async_readable_stream&lt;int&gt; <span class="keyword">auto</span> new_stream = stream | take_while([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i &lt; 2; });</div>
<div class="line"><span class="comment">// streams returned is [1,2]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md15"></a>
Drop while adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> drop_while(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to drop the values sent through the stream while the predicate defined by <code>Func</code> yields true. <code>Func</code> must have the following type signature <code>bool(const T&amp;)</code>. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line">async_readable_stream&lt;int&gt; <span class="keyword">auto</span> new_stream = stream | drop_while([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i &lt; 2; });</div>
<div class="line"><span class="comment">// streams returned is [3,4,5]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16"></a>
Collect adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> ToType, <span class="keyword">typename</span> StreamType&gt;</div>
<div class="line"><span class="keyword">concept </span>collector = std::is_invocable_r_v&lt;task&lt;ToType&gt;, Derived, async_generator&lt;StreamType&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ToType, <span class="keyword">typename</span> StreamType, collector&lt;ToType, StreamType&gt; Collector&gt;</div>
<div class="line"><span class="keyword">auto</span> collect(Collector &amp;&amp;collector_func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'll be able to convert the readable stream into something more tangible like another object or a <code>std::vector</code> of an object. This would be really useful especially for processing of REST requests when they give you a stream of bytes, you'll be able to collect it into a JSON object.</p>
<p>There are many ways to create your own collector, you can create your own, for example to convert a stream of bytes into a JSON object, or you can use some of the in-built ones:</p>
<ul>
<li>reduce</li>
<li>joining</li>
<li>to_vector</li>
<li>group_by</li>
</ul>
<h4><a class="anchor" id="autotoc_md17"></a>
Reduce collector</h4>
<p>Defined as shown:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> reduce(std::function&lt;T(T, T)&gt; &amp;&amp;func);</div>
</div><!-- fragment --><p>When collected, this will return a <code>task&lt;T&gt;</code> which can be awaited to give you the result. For example:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keywordtype">int</span> values = <span class="keyword">co_await</span> (stream | collect(collectors::reduce([](<span class="keywordtype">int</span> first, <span class="keywordtype">int</span> second) { <span class="keywordflow">return</span> first + second; })));</div>
<div class="line">assert(values == 15);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md18"></a>
Joining collector</h4>
<p>Defined as shown:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span> std::is_convertible_v&lt;T, std::string&gt;</div>
<div class="line"><span class="keyword">auto</span> joining(std::string separator = <span class="stringliteral">&quot;&quot;</span>, std::string prefix = <span class="stringliteral">&quot;&quot;</span>, std::string suffix = <span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><p>When collected, this will return a <code>task&lt;std::string&gt;</code> which can be awaited to give you the result. For example:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>});</div>
<div class="line">std::string values = <span class="keyword">co_await</span> (stream | collect(collectors::joinin(<span class="stringliteral">&quot;,&quot;</span>)));</div>
<div class="line">assert(values == <span class="stringliteral">&quot;1,2,3,4,5&quot;</span>);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md19"></a>
To Vector collector</h4>
<p>Defined as shown:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> to_vector();</div>
</div><!-- fragment --><p>When collected, this will return a <code>task&lt;std::vector&lt;T&gt;&gt;</code> which can be awaited to give you the result. For example:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line">std::vector&lt;int&gt; values = <span class="keyword">co_await</span> (stream | collect(collectors::to_vector()));</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; values.size(); i++) {</div>
<div class="line">    assert(values[i] == i + 1);</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md20"></a>
Group By collector</h4>
<p>Defined as shown:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> KeyType&gt;</div>
<div class="line"><span class="keyword">auto</span> group_by(std::function&lt;KeyType(<span class="keyword">const</span> T &amp;)&gt; key_function);</div>
</div><!-- fragment --><p>When collected, this will return a <code>task&lt;std::unordered_map&lt;KeyType, std::vector&lt;T&gt;&gt;&gt;</code> which can be awaited to give you the result. Example:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;std::string&gt; stream({<span class="stringliteral">&quot;AB&quot;</span>, <span class="stringliteral">&quot;BC&quot;</span>, <span class="stringliteral">&quot;AC&quot;</span>, <span class="stringliteral">&quot;BD&quot;</span>, <span class="stringliteral">&quot;CD&quot;</span>});</div>
<div class="line"><span class="keyword">auto</span> mapper = [](std::string value) -&gt; std::string { <span class="comment">// groups it by the first letter</span></div>
<div class="line">    <span class="keywordflow">return</span> std::string(value[0]); <span class="comment">// A* -&gt; A, B* -&gt; B</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a467323c557b8245b25c7cc5c6cd28e22">map</a> = <span class="keyword">co_await</span> (stream | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#ac259db7916278ffc530b8c127be7a191">collect</a>(collectors::group_by(mapper)));</div>
<div class="line"><span class="comment">//  returns a { {&quot;A&quot;, [&quot;AB&quot;,&quot;AC&quot;]}, {&quot;B&quot;, [&quot;BC&quot;,&quot;BD&quot;]}, {&quot;C&quot;, [&quot;CD&quot;]} }</span></div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_ac259db7916278ffc530b8c127be7a191"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#ac259db7916278ffc530b8c127be7a191">webcraft::async::io::adaptors::collect</a></div><div class="ttdeci">auto collect(Collector &amp;&amp;collector_func)</div><div class="ttdef"><b>Definition</b> adaptors.hpp:117</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21"></a>
Forward To adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> forward_to(async_writable_stream&lt;T&gt; <span class="keyword">auto</span> &amp;stream) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'll be able to forward all objects coming from the readable stream into the output stream passed. When applied, the adaptor will return a <code>task&lt;void&gt;</code> which you can await for all the values to be sent into the stream. An example of this is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; rstream({1,2,3,4,5});</div>
<div class="line">mock_writable_stream&lt;int&gt; wstream;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">co_await</span> (rstream | forward_to(wstream));</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= 5; i++) {</div>
<div class="line">    assert(wstream.received(i));</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22"></a>
Min adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span> std::totally_ordered&lt;T&gt;</div>
<div class="line"><span class="keyword">auto</span> min() -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to find the minimum value sent through the stream. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keywordtype">int</span> min_value = <span class="keyword">co_await</span> (stream | min());</div>
<div class="line">assert(min_value == 1);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md23"></a>
Max adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span> std::totally_ordered&lt;T&gt;</div>
<div class="line"><span class="keyword">auto</span> max() -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to find the maximum value sent through the stream. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keywordtype">int</span> max_value = <span class="keyword">co_await</span> (stream | max());</div>
<div class="line">assert(max_value == 5);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md24"></a>
Sum adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>closure_under_addition = <span class="keyword">requires</span>(T a, T b) {</div>
<div class="line">    { a + b } -&gt; std::convertible_to&lt;T&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span> closure_under_addition&lt;T&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a01eae8f829e97817419aed01f5ad37dc">sum</a>() -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_a01eae8f829e97817419aed01f5ad37dc"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a01eae8f829e97817419aed01f5ad37dc">webcraft::async::io::adaptors::sum</a></div><div class="ttdeci">auto sum()</div><div class="ttdef"><b>Definition</b> adaptors.hpp:380</div></div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to find the sum of the values sent through the stream. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keywordtype">int</span> sum = <span class="keyword">co_await</span> (stream | sum());</div>
<div class="line">assert(sum == 15);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25"></a>
Find first adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> find_first(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to find the first value sent through the stream which matches the following predicate. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keywordtype">int</span> value = <span class="keyword">co_await</span> (stream | find_first([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(value == 2);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md26"></a>
Find last adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> find_last(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to find the last value sent through the stream which matches the following predicate. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keywordtype">int</span> value = <span class="keyword">co_await</span> (stream | find_last([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(value == 4);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md27"></a>
Any matches adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> any_matches(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to check if there are any values which match the predicate. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream_1({2,4,3,5});</div>
<div class="line">mock_readable_stream&lt;int&gt; stream_2({1,3,5});</div>
<div class="line"><span class="keywordtype">bool</span> check1 = <span class="keyword">co_await</span> (stream_1 | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#af103d36599b9cd7baf15f2c7e75e70b9">any_matches</a>([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(check1);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> check2 = <span class="keyword">co_await</span> (stream_2 | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#af103d36599b9cd7baf15f2c7e75e70b9">any_matches</a>([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(!check2);</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_af103d36599b9cd7baf15f2c7e75e70b9"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#af103d36599b9cd7baf15f2c7e75e70b9">webcraft::async::io::adaptors::any_matches</a></div><div class="ttdeci">auto any_matches(std::function&lt; bool(const T &amp;)&gt; &amp;&amp;predicate)</div><div class="ttdef"><b>Definition</b> adaptors.hpp:418</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28"></a>
All matches adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> all_matches(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to check if all values which match the predicate. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream_1({2,4,6,8});</div>
<div class="line">mock_readable_stream&lt;int&gt; stream_2({2,4,6,7});</div>
<div class="line"><span class="keywordtype">bool</span> check1 = <span class="keyword">co_await</span> (stream_1 | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a1566ca935350435b72631ee11d574ee7">all_matches</a>([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(check1);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> check2 = <span class="keyword">co_await</span> (stream_2 | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a1566ca935350435b72631ee11d574ee7">all_matches</a>([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(!check2);</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_a1566ca935350435b72631ee11d574ee7"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a1566ca935350435b72631ee11d574ee7">webcraft::async::io::adaptors::all_matches</a></div><div class="ttdeci">auto all_matches(std::function&lt; bool(const T &amp;)&gt; &amp;&amp;predicate)</div><div class="ttdef"><b>Definition</b> adaptors.hpp:433</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md29"></a>
None matches adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> any_matches(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to check if all values do not match the predicate. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream_1({2,4,3,5});</div>
<div class="line">mock_readable_stream&lt;int&gt; stream_2({1,3,5});</div>
<div class="line"><span class="keywordtype">bool</span> check1 = <span class="keyword">co_await</span> (stream_1 | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#af0226fefe32175663e7ab469a785566c">none_matches</a>([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(!check1);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> check2 = <span class="keyword">co_await</span> (stream_2 | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#af0226fefe32175663e7ab469a785566c">none_matches</a>([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(check2);</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_af0226fefe32175663e7ab469a785566c"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#af0226fefe32175663e7ab469a785566c">webcraft::async::io::adaptors::none_matches</a></div><div class="ttdeci">auto none_matches(std::function&lt; bool(const T &amp;)&gt; &amp;&amp;predicate)</div><div class="ttdef"><b>Definition</b> adaptors.hpp:448</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md30"></a>
Some of the adaptors are planned to be implemented in this framework:</h2>
<h3><a class="anchor" id="autotoc_md31"></a>
Sorted adaptor</h3>
<p>Definition is as shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">requires</span> std::totally_ordered&lt;T&gt;</div>
<div class="line"><span class="keyword">auto</span> sorted() -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">requires</span> std::totally_ordered&lt;R&gt;</div>
<div class="line"><span class="keyword">auto</span> sorted(std::function&lt;R(T)&gt; comparator) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor on a readable stream will create a new sorted readable stream from the old stream (all values will be sorted in the order specified). An example of the usage is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; values_1({5,1,3,6,4,2});</div>
<div class="line">async_readable_stream&lt;int&gt; <span class="keyword">auto</span> new_stream_1 = values_1 | sorted(); <span class="comment">// 1,2,3,4,5,6</span></div>
<div class="line"><span class="comment">// the new steam satisfies async_readable_stream&lt;1&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// another example</span></div>
<div class="line">mock_readable_stream&lt;std::pair&lt;int, std::string&gt;&gt; values_2({{5,<span class="stringliteral">&quot;5&quot;</span>}, {1,<span class="stringliteral">&quot;1&quot;</span>}, {<span class="stringliteral">&quot;3&quot;</span>,3}, {6,<span class="stringliteral">&quot;6&quot;</span>}, {4,<span class="stringliteral">&quot;4&quot;</span>},{2,<span class="stringliteral">&quot;2&quot;</span>}});</div>
<div class="line">async_readable_stream&lt;std::pair&lt;int, std::string&gt;&gt; <span class="keyword">auto</span> new_stream_2 = values_2 | sorted([](<span class="keyword">auto</span> value) { <span class="keywordflow">return</span> value.key; }); <span class="comment">// {1,&quot;1&quot;},{2,&quot;2&quot;},{3,&quot;3&quot;},{4,&quot;4&quot;},{5,&quot;5&quot;},{6,&quot;6&quot;}</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md32"></a>
Zip adaptor</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">auto</span> zip_inner(async_readable_stream&lt;R&gt; str) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">auto</span> zip_left(async_readable_stream&lt;R&gt; str) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">auto</span> zip_right(async_readable_stream&lt;R&gt; str) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">auto</span> zip_full(async_readable_stream&lt;R&gt; str) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor you'll be able to group 2 streams together into one. An example of this is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream1({1,2,3,4,5});</div>
<div class="line">mock_readable_stream&lt;std::string&gt; stream2({<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>});</div>
<div class="line"> </div>
<div class="line">async_readable_stream&lt;std::pair&lt;std::optional&lt;int&gt;, std::optional&lt;std::string&gt;&gt;&gt; <span class="keyword">auto</span> new_stream = stream1 | zip_full(stream2); <span class="comment">// {1,&quot;1&quot;},{2,&quot;2&quot;},{3,&quot;3&quot;},{4,&quot;4&quot;},{5,&quot;5&quot;},{6,&quot;6&quot;}</span></div>
<div class="line"><span class="comment">// the new steam satisfies async_readable_stream&lt;std::pair&lt;std::optional&lt;int&gt;, std::optional&lt;std::string&gt;&gt;&gt;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md33"></a>
Async File I/O</h1>
<p>Async File I/O is handled differently on different platforms. Here are some of the provided features of these on the different platforms by the different frameworks:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Library   </th><th class="markdownTableHeadNone">Platforms Supported   </th><th class="markdownTableHeadNone">Special Create?   </th><th class="markdownTableHeadNone">Async Read?   </th><th class="markdownTableHeadNone">Async Write?   </th><th class="markdownTableHeadNone">Async Close?   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">IO Completion Ports   </td><td class="markdownTableBodyNone">Windows Only (<code>&lt;windows.h&gt;</code>)   </td><td class="markdownTableBodyNone">Synchronous but sets up async IO:<a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea"><code>CreateFileEx</code></a> + <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/createiocompletionport"><code>CreateIOCompletionPort</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile"><code>ReadFile</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile"><code>WriteFile</code></a>   </td><td class="markdownTableBodyNone">No Async Version. Just <a href="https://learn.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle"><code>CloseHandle</code></a>   </td><td class="markdownTableBodyNone"><b>Summary:</b> Synchronous create and close and async read and write but only for windows.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">io_uring   </td><td class="markdownTableBodyNone">Linux Only (<code>&lt;liburing.h&gt;</code>)   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_open.3.html"><code>io_uring_prep_open</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_read.3.html"><code>io_uring_prep_read</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_write.3.html"><code>io_uring_prep_write</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_close.3.html"><code>io_uring_prep_close</code></a>   </td><td class="markdownTableBodyNone"><b>Summary:</b> Has async support for all file functions but only for linux    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kqueue + aio   </td><td class="markdownTableBodyNone">Pure BSD-based systems like FreeBSD (<code>&lt;sys/event.h&gt;</code> + <code>&lt;aio.h&gt;</code>)   </td><td class="markdownTableBodyNone">Synchronous: Use POSIX<code>open</code>   </td><td class="markdownTableBodyNone">Use<code>aio_read</code> with kqueue   </td><td class="markdownTableBodyNone">Use<code>aio_write</code> with   </td><td class="markdownTableBodyNone">Synchronous: Use <code>close</code>   </td><td class="markdownTableBodyNone"><b>NOTE: Make sure when the kqueue result has returned to call <code>aio_return</code>.</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread pool   </td><td class="markdownTableBodyNone">MacOS or any other system which does not support Async File I/O natively   </td><td class="markdownTableBodyNone">Synchronous: Use POSIX<code>open</code>   </td><td class="markdownTableBodyNone">Use<code>read</code> on thread pool   </td><td class="markdownTableBodyNone">Use<code>write</code> on thread   </td><td class="markdownTableBodyNone">Synchronous: Use<code>close</code>   </td><td class="markdownTableBodyNone">Use a thread pool    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GCD   </td><td class="markdownTableBodyNone">MacOS Only - plan on implementing this in the next PR   </td><td class="markdownTableBodyNone">tbd   </td><td class="markdownTableBodyNone">tdb   </td><td class="markdownTableBodyNone">tdb   </td><td class="markdownTableBodyNone">tdb   </td><td class="markdownTableBodyNone">Need to look into this more   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md34"></a>
Async Socket I/O</h1>
<p>Async Socket I/O is handled differently on different platforms.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
TCP Sockets</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Library   </th><th class="markdownTableHeadNone">Platforms Supported   </th><th class="markdownTableHeadNone">Special Create?   </th><th class="markdownTableHeadNone">Async Connect?   </th><th class="markdownTableHeadNone">Async Read?   </th><th class="markdownTableHeadNone">Async Write?   </th><th class="markdownTableHeadNone">Async Close?   </th><th class="markdownTableHeadNone">Async Shutdown?   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">io_uring   </td><td class="markdownTableBodyNone">Linux   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_socket.3.html"><code>io_uring_prep_socket</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_connect.3.html"><code>io_uring_prep_connect</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_read.3.html"><code>io_uring_prep_read</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_write.3.html"><code>io_uring_prep_write</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_close.3.html"><code>io_uring_prep_close</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_shutdown.3.html"><code>io_uring_prep_shutdown</code></a>   </td><td class="markdownTableBodyNone"><b>NOTE: All the functions are async just linux only.</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">IOCP   </td><td class="markdownTableBodyNone">Windows   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket"><code>socket</code></a> + <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/createiocompletionport"><code>CreateIOCompletionPort</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_connectex"><code>ConnectEx</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-gb/windows/win32/api/winsock2/nf-winsock2-wsarecv"><code>WSARecv</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-gb/windows/win32/api/winsock2/nf-winsock2-wsasend"><code>WSASend</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-closesocket"><code>closesocket</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-shutdown"><code>shutdown</code></a>   </td><td class="markdownTableBodyNone"><b>NOTE: A call to <code>bind()</code> must be made before calling ConnectEx otherwise socket will be invalid.</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kqueue   </td><td class="markdownTableBodyNone">BSD based systems   </td><td class="markdownTableBodyNone"><code>socket</code>   </td><td class="markdownTableBodyNone"><code>connect</code>   </td><td class="markdownTableBodyNone"><code>read</code>   </td><td class="markdownTableBodyNone"><code>write</code>   </td><td class="markdownTableBodyNone"><code>close</code>   </td><td class="markdownTableBodyNone"><code>shutdown</code>   </td><td class="markdownTableBodyNone"><b>NOTE: It seems like it's all just synchronous API calls but kqueue lets us know when to call what under the hood. Kqueue will be our notification agent and we'll use channels and other forms of asynchronous delivery to let us know when to resume. Refer to the kqueue example below.</b>   </td></tr>
</table>
<p>Some docs:</p><ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_connectex">https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_connectex</a></li>
<li><a href="https://gist.github.com/joeyadams/4158972">https://gist.github.com/joeyadams/4158972</a></li>
<li><a href="https://stackoverflow.com/questions/13598530/connectex-requires-the-socket-to-be-initially-bound-but-to-what">https://stackoverflow.com/questions/13598530/connectex-requires-the-socket-to-be-initially-bound-but-to-what</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md36"></a>
TCP Listeners</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Library   </th><th class="markdownTableHeadNone">Platforms Supported   </th><th class="markdownTableHeadNone">Special Create?   </th><th class="markdownTableHeadNone">Async Bind?   </th><th class="markdownTableHeadNone">Async Listen?   </th><th class="markdownTableHeadNone">Async Accept   </th><th class="markdownTableHeadNone">Async Close?   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">io_uring   </td><td class="markdownTableBodyNone">Linux   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_socket.3.html"><code>io_uring_prep_socket</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_bind.3.html"><code>io_uring_prep_bind</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_listen.3.html"><code>io_uring_prep_listen</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_accept.3.html"><code>io_uring_prep_accept</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_close.3.html"><code>io_uring_prep_close</code></a>   </td><td class="markdownTableBodyNone"><b>NOTE: All the functions are async just linux only.</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">IOCP   </td><td class="markdownTableBodyNone">Windows   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket"><code>socket</code></a> + <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/createiocompletionport"><code>CreateIOCompletionPort</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-bind"><code>bind</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen"><code>listen</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-gb/windows/win32/api/mswsock/nf-mswsock-acceptex"><code>AcceptEx</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-closesocket"><code>closesocket</code></a>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kqueue   </td><td class="markdownTableBodyNone">BSD based systems   </td><td class="markdownTableBodyNone"><code>socket</code>   </td><td class="markdownTableBodyNone"><code>bind</code>   </td><td class="markdownTableBodyNone"><code>listen</code>   </td><td class="markdownTableBodyNone"><code>accept</code>   </td><td class="markdownTableBodyNone"><code>close</code>   </td><td class="markdownTableBodyNone"><b>NOTE: It seems like it's all just synchronous API calls but kqueue lets us know when to call what under the hood. Kqueue will be our notification agent and we'll use channels and other forms of asynchronous delivery to let us know when to resume. Refer to the kqueue example below.</b>   </td></tr>
</table>
<p>Examples:</p><ul>
<li><a href="https://learn.microsoft.com/en-gb/windows/win32/api/mswsock/nf-mswsock-acceptex#example-code">https://learn.microsoft.com/en-gb/windows/win32/api/mswsock/nf-mswsock-acceptex#example-code</a></li>
<li><a href="https://gist.github.com/josephg/6c078a241b0e9e538ac04ef28be6e787">https://gist.github.com/josephg/6c078a241b0e9e538ac04ef28be6e787</a></li>
<li>KQUEUE Example: <a href="https://dev.to/frevib/a-tcp-server-with-kqueue-527">https://dev.to/frevib/a-tcp-server-with-kqueue-527</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md37"></a>
Planned implementation:</h1>
<p>Async Read &amp; Async Write will be based on what's in the <b>Async Read</b> and <b>Async Write</b> columns. Closing will still happen with RAII (which would be a synchronous close on everything but linux) but on linux we'll send a fire-and-forget request with <code>io_uring_prep_close</code>. For async creation it can either be with synchronous or asynchronous, the bottleneck wouldn't be too big of an issue.</p>
<p>This is the following specification for using the <b>Async File I/O</b> API: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>detail</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>file_descriptor</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        std::ios_base::openmode mode;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        file_descriptor(std::ios_base::openmode mode) : mode(mode) {}</div>
<div class="line">        <span class="keyword">virtual</span> ~file_descriptor() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// virtual because we want to allow platform specific implementation</span></div>
<div class="line">        <span class="keyword">virtual</span> task&lt;size_t&gt; read(std::span&lt;char&gt; buffer) = 0;  <span class="comment">// internally should check if openmode is for read</span></div>
<div class="line">        <span class="keyword">virtual</span> task&lt;size_t&gt; write(std::span&lt;char&gt; buffer) = 0; <span class="comment">// internally should check if openmode is for write or append</span></div>
<div class="line">        <span class="keyword">virtual</span> task&lt;void&gt; close() = 0;                         <span class="comment">// will spawn a fire and forget task (essentially use async apis but provide null callback)</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    task&lt;std::shared_ptr&lt;file_descriptor&gt;&gt; make_file_descriptor(std::filesystem::path p, std::ios_base::openmode mode);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>file_stream</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        std::shared_ptr&lt;file_descriptor&gt; fd;</div>
<div class="line">        std::atomic&lt;bool&gt; closed{<span class="keyword">false</span>};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">explicit</span> file_stream(std::shared_ptr&lt;file_descriptor&gt; fd) : fd(std::move(fd)) {}</div>
<div class="line">        <span class="keyword">virtual</span> ~file_stream() noexcept</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (fd)</div>
<div class="line">                <a class="code hl_function" href="namespacewebcraft_1_1async.html#a367712ca561ac34d7d28f495a6462c09">sync_wait</a>(close());</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        task&lt;void&gt; close() noexcept</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">bool</span> expected = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">if</span> (closed.compare_exchange_strong(expected, <span class="keyword">true</span>, std::memory_order_acq_rel))</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">co_await</span> fd-&gt;close();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>file_rstream : <span class="keyword">public</span> detail::file_stream</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    file_rstream(std::shared_ptr&lt;detail::file_descriptor&gt; fd) : detail::file_stream(std::move(fd)) {}</div>
<div class="line">    ~file_rstream() noexcept = default;</div>
<div class="line"> </div>
<div class="line">    file_rstream(file_rstream &amp;&amp;) noexcept = default;</div>
<div class="line">    file_rstream &amp;operator=(file_rstream &amp;&amp;) noexcept = default;</div>
<div class="line"> </div>
<div class="line">    task&lt;<span class="keywordtype">size_t</span>&gt; recv(std::span&lt;<span class="keywordtype">char</span>&gt; buffer)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> fd-&gt;read(buffer);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    task&lt;char&gt; <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#aaaf5c2dda44d2ea9c9518aa85bf729c1">recv</a>()</div>
<div class="line">    {</div>
<div class="line">        std::array&lt;char, 1&gt; buf;</div>
<div class="line">        <span class="keyword">co_await</span> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#aaaf5c2dda44d2ea9c9518aa85bf729c1">recv</a>(buf);</div>
<div class="line">        <span class="keyword">co_return</span> buf[0];</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(async_readable_stream&lt;file_rstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_buffered_readable_stream&lt;file_rstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_closeable_stream&lt;file_rstream, char&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>file_wstream : <span class="keyword">public</span> detail::file_stream</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> file_wstream(std::shared_ptr&lt;file_descriptor&gt; fd) : detail::file_stream(std::move(fd)) {}</div>
<div class="line">    ~file_wstream() noexcept = default;</div>
<div class="line"> </div>
<div class="line">    file_wstream(file_wstream &amp;&amp;) noexcept = default;</div>
<div class="line">    file_wstream &amp;operator=(file_wstream &amp;&amp;) noexcept = default;</div>
<div class="line"> </div>
<div class="line">    task&lt;<span class="keywordtype">size_t</span>&gt; send(std::span&lt;<span class="keywordtype">char</span>&gt; buffer)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> fd-&gt;write(buffer);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    task&lt;bool&gt; <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#af2b81544adcc4ba129f31b5797a43670">send</a>(<span class="keywordtype">char</span> b)</div>
<div class="line">    {</div>
<div class="line">        std::array&lt;char, 1&gt; buf;</div>
<div class="line">        buf[0] = b;</div>
<div class="line">        <span class="keyword">co_await</span> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#af2b81544adcc4ba129f31b5797a43670">send</a>(buf);</div>
<div class="line">        <span class="keyword">co_return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(async_writable_stream&lt;file_wstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_buffered_writable_stream&lt;file_wstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_closeable_stream&lt;file_wstream, char&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>file</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::filesystem::path p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    file(std::filesystem::path p) : p(std::move(p)) {}</div>
<div class="line">    ~file() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    task&lt;file_rstream&gt; open_readable_stream()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> descriptor = <span class="keyword">co_await</span> detail::make_file_descriptor(p, std::ios_base::in);</div>
<div class="line">        <span class="keyword">co_return</span> file_rstream(descriptor);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    task&lt;file_wstream&gt; open_writable_stream(<span class="keywordtype">bool</span> append)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> descriptor = <span class="keyword">co_await</span> detail::make_file_descriptor(p, append ? std::ios_base::app : std::ios_base::out);</div>
<div class="line">        <span class="keyword">co_return</span> file_wstream(std::move(descriptor));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">const</span> std::filesystem::path get_path()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> p; }</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="keyword">const</span> std::filesystem::path &amp;() <span class="keyword">const</span> { <span class="keywordflow">return</span> p; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">file <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1fs.html#a8d8e45ed576cda72f736cd9e66952947">make_file</a>(std::filesystem::path p)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> file(p);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1fs_html_a8d8e45ed576cda72f736cd9e66952947"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1fs.html#a8d8e45ed576cda72f736cd9e66952947">webcraft::async::io::fs::make_file</a></div><div class="ttdeci">file make_file(std::filesystem::path p)</div><div class="ttdef"><b>Definition</b> fs.hpp:159</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_html_aaaf5c2dda44d2ea9c9518aa85bf729c1"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io.html#aaaf5c2dda44d2ea9c9518aa85bf729c1">webcraft::async::io::recv</a></div><div class="ttdeci">auto recv(async_readable_stream&lt; R &gt; auto &amp;stream)</div><div class="ttdef"><b>Definition</b> core.hpp:51</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_html_af2b81544adcc4ba129f31b5797a43670"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io.html#af2b81544adcc4ba129f31b5797a43670">webcraft::async::io::send</a></div><div class="ttdeci">task&lt; bool &gt; send(WStream &amp;stream, R &amp;&amp;value)</div><div class="ttdef"><b>Definition</b> core.hpp:81</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_html_a367712ca561ac34d7d28f495a6462c09"><div class="ttname"><a href="namespacewebcraft_1_1async.html#a367712ca561ac34d7d28f495a6462c09">webcraft::async::sync_wait</a></div><div class="ttdeci">awaitable_resume_t&lt; T &gt; sync_wait(T &amp;&amp;awaitable)</div><div class="ttdef"><b>Definition</b> sync_wait.hpp:16</div></div>
</div><!-- fragment --><p>This is the following specification for using the <b>Async TCP Socket and Listener I/O</b> API: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>connection_info</div>
<div class="line">{</div>
<div class="line">    std::string host;</div>
<div class="line">    uint16_t port;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum class</span> socket_stream_mode</div>
<div class="line">{</div>
<div class="line">    READ,</div>
<div class="line">    WRITE</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>detail</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>tcp_descriptor_base</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        tcp_descriptor_base() = <span class="keywordflow">default</span>;</div>
<div class="line">        <span class="keyword">virtual</span> ~tcp_descriptor_base() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">virtual</span> task&lt;void&gt; close() = 0; <span class="comment">// Close the socket</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>tcp_socket_descriptor : <span class="keyword">public</span> tcp_descriptor_base</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        tcp_socket_descriptor() = <span class="keywordflow">default</span>;</div>
<div class="line">        <span class="keyword">virtual</span> ~tcp_socket_descriptor() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">virtual</span> task&lt;void&gt; connect(<span class="keyword">const</span> connection_info &amp;info) = 0;  <span class="comment">// Connect to a server</span></div>
<div class="line">        <span class="keyword">virtual</span> task&lt;size_t&gt; read(std::span&lt;char&gt; buffer) = 0;        <span class="comment">// Read data from the socket</span></div>
<div class="line">        <span class="keyword">virtual</span> task&lt;size_t&gt; write(std::span&lt;const char&gt; buffer) = 0; <span class="comment">// Write data to the socket</span></div>
<div class="line">        <span class="keyword">virtual</span> task&lt;void&gt; <a class="code hl_function" href="namespacewebcraft_1_1async.html#a32cc887e48f12d360656c6f023977a2d">shutdown</a>(socket_stream_mode mode) = 0;     <span class="comment">// Shutdown the socket</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>tcp_listener_descriptor : <span class="keyword">public</span> tcp_descriptor_base</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        tcp_listener_descriptor() = <span class="keywordflow">default</span>;</div>
<div class="line">        <span class="keyword">virtual</span> ~tcp_listener_descriptor() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">virtual</span> task&lt;void&gt; bind(<span class="keyword">const</span> connection_info &amp;info) = 0;          <span class="comment">// Bind the listener to an address</span></div>
<div class="line">        <span class="keyword">virtual</span> task&lt;void&gt; listen(<span class="keywordtype">int</span> backlog) = 0;                        <span class="comment">// Start listening for incoming connections</span></div>
<div class="line">        <span class="keyword">virtual</span> task&lt;std::unique_ptr&lt;tcp_socket_descriptor&gt;&gt; accept() = 0; <span class="comment">// Accept a new connection</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    task&lt;std::shared_ptr&lt;tcp_socket_descriptor&gt;&gt; make_tcp_socket_descriptor();</div>
<div class="line">    task&lt;std::shared_ptr&lt;tcp_listener_descriptor&gt;&gt; make_tcp_listener_descriptor();</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>tcp_rstream</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;detail::tcp_socket_descriptor&gt; descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    tcp_rstream(std::shared_ptr&lt;detail::tcp_socket_descriptor&gt; desc) : descriptor(std::move(desc)) {}</div>
<div class="line">    ~tcp_rstream() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    task&lt;size_t&gt; <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#aaaf5c2dda44d2ea9c9518aa85bf729c1">recv</a>(std::span&lt;char&gt; buffer)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> descriptor-&gt;read(buffer);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    task&lt;char&gt; <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#aaaf5c2dda44d2ea9c9518aa85bf729c1">recv</a>()</div>
<div class="line">    {</div>
<div class="line">        std::array&lt;char, 1&gt; buf;</div>
<div class="line">        <span class="keyword">co_await</span> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#aaaf5c2dda44d2ea9c9518aa85bf729c1">recv</a>(buf);</div>
<div class="line">        <span class="keyword">co_return</span> buf[0];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    task&lt;void&gt; close()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">co_await</span> descriptor-&gt;shutdown(socket_stream_mode::READ);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(async_writable_stream&lt;tcp_rstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_buffered_writable_stream&lt;tcp_rstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_closeable_stream&lt;tcp_rstream, char&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>tcp_wstream</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;detail::tcp_socket_descriptor&gt; descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    tcp_wstream(std::shared_ptr&lt;detail::tcp_socket_descriptor&gt; desc) : descriptor(std::move(desc)) {}</div>
<div class="line">    ~tcp_wstream() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    task&lt;size_t&gt; <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#af2b81544adcc4ba129f31b5797a43670">send</a>(std::span&lt;const char&gt; buffer)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> descriptor-&gt;write(buffer);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    task&lt;bool&gt; <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#af2b81544adcc4ba129f31b5797a43670">send</a>(<span class="keywordtype">char</span> b)</div>
<div class="line">    {</div>
<div class="line">        std::array&lt;char, 1&gt; buf;</div>
<div class="line">        buf[0] = b;</div>
<div class="line">        <span class="keyword">co_await</span> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#af2b81544adcc4ba129f31b5797a43670">send</a>(buf);</div>
<div class="line">        <span class="keyword">co_return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    task&lt;void&gt; close()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">co_await</span> descriptor-&gt;shutdown(socket_stream_mode::WRITE);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(async_writable_stream&lt;tcp_wstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_buffered_writable_stream&lt;tcp_wstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_closeable_stream&lt;tcp_wstream, char&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>tcp_socket</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;detail::tcp_socket_descriptor&gt; descriptor;</div>
<div class="line">    std::unique_ptr&lt;tcp_rstream&gt; read_stream;</div>
<div class="line">    std::unique_ptr&lt;tcp_wstream&gt; write_stream;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    tcp_socket(std::shared_ptr&lt;detail::tcp_socket_descriptor&gt; desc) : descriptor(std::move(desc)) {}</div>
<div class="line">    ~tcp_socket()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (read_stream)</div>
<div class="line">        {</div>
<div class="line">            read_stream-&gt;close();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (write_stream)</div>
<div class="line">        {</div>
<div class="line">            write_stream-&gt;close();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (descriptor)</div>
<div class="line">        {</div>
<div class="line">            <a class="code hl_function" href="namespacewebcraft_1_1async.html#a367712ca561ac34d7d28f495a6462c09">sync_wait</a>(descriptor-&gt;close());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    task&lt;void&gt; connect(<span class="keyword">const</span> connection_info &amp;info)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">co_await</span> descriptor-&gt;connect(info);</div>
<div class="line">        read_stream = std::make_unique&lt;tcp_rstream&gt;(descriptor);</div>
<div class="line">        write_stream = std::make_unique&lt;tcp_wstream&gt;(descriptor);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    tcp_rstream &amp;get_readable_stream()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!read_stream)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Read stream is not initialized.&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> *read_stream;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    tcp_wstream &amp;get_writable_stream()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!write_stream)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Write stream is not initialized.&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> *write_stream;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    task&lt;void&gt; shutdown_channel(socket_stream_mode mode)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (mode == socket_stream_mode::READ &amp;&amp; read_stream)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">co_await</span> read_stream-&gt;close();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mode == socket_stream_mode::WRITE &amp;&amp; write_stream)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">co_await</span> write_stream-&gt;close();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>tcp_listener</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;detail::tcp_listener_descriptor&gt; descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    tcp_listener(std::shared_ptr&lt;detail::tcp_listener_descriptor&gt; desc) : descriptor(std::move(desc)) {}</div>
<div class="line">    ~tcp_listener()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (descriptor)</div>
<div class="line">        {</div>
<div class="line">            <a class="code hl_function" href="namespacewebcraft_1_1async.html#a367712ca561ac34d7d28f495a6462c09">sync_wait</a>(descriptor-&gt;close());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    task&lt;void&gt; bind(<span class="keyword">const</span> connection_info &amp;info)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> descriptor-&gt;bind(info);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    task&lt;void&gt; listen(<span class="keywordtype">int</span> backlog)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> descriptor-&gt;listen(backlog);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    task&lt;std::unique_ptr&lt;tcp_socket&gt;&gt; accept()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> client_desc = <span class="keyword">co_await</span> descriptor-&gt;accept();</div>
<div class="line">        <span class="keyword">co_return</span> std::make_unique&lt;tcp_socket&gt;(std::move(client_desc));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">task&lt;tcp_socket&gt; <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1socket.html#a482e358e1f53606e06109999484276b3">make_tcp_socket</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> descriptor = <span class="keyword">co_await</span> detail::make_tcp_socket_descriptor();</div>
<div class="line">    <span class="keyword">co_return</span> tcp_socket(std::move(descriptor));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">task&lt;tcp_listener&gt; <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1socket.html#a861e0c806d177e378bae72a3cfb5f0e2">make_tcp_listener</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> descriptor = <span class="keyword">co_await</span> detail::make_tcp_listener_descriptor();</div>
<div class="line">    <span class="keyword">co_return</span> tcp_listener(std::move(descriptor));</div>
<div class="line">}</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1socket_html_a482e358e1f53606e06109999484276b3"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1socket.html#a482e358e1f53606e06109999484276b3">webcraft::async::io::socket::make_tcp_socket</a></div><div class="ttdeci">tcp_socket make_tcp_socket()</div><div class="ttdef"><b>Definition</b> socket.hpp:288</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1socket_html_a861e0c806d177e378bae72a3cfb5f0e2"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1socket.html#a861e0c806d177e378bae72a3cfb5f0e2">webcraft::async::io::socket::make_tcp_listener</a></div><div class="ttdeci">tcp_listener make_tcp_listener()</div><div class="ttdef"><b>Definition</b> socket.hpp:293</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_html_a32cc887e48f12d360656c6f023977a2d"><div class="ttname"><a href="namespacewebcraft_1_1async.html#a32cc887e48f12d360656c6f023977a2d">webcraft::async::shutdown</a></div><div class="ttdeci">task&lt; void &gt; shutdown()</div><div class="ttdef"><b>Definition</b> runtime.hpp:245</div></div>
</div><!-- fragment --><p>The platform will implement <code>make_file_descriptor</code>, <code>make_tcp_socket_descriptor</code>, and <code>make_tcp_socket_descriptor</code> while also making their own implementations of the socket and file descriptors and returning a shared pointer via the functions mentioned. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
