<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>WebCraft: Asynchronous I/O in WebCraft</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">WebCraft<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">An async first C++ framework leveraging powerful features of C++23 built for scale, speed, and ease.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_include_2webcraft_2async_2io_2README.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Asynchronous I/O in WebCraft</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> This readme covers how WebCraft handles <b>Asynchronous I/O</b> powered with C++ coroutines.</p>
<p>Table of Contents:</p>
<ol type="1">
<li>Async Streams</li>
<li>Async Readable Stream Adaptors</li>
<li>Async File I/O</li>
<li>Async Socket I/O</li>
</ol>
<h1><a class="anchor" id="autotoc_md1"></a>
Async Streams</h1>
<p>Async I/O in webcraft is implemented using the concept of Streams (similar to Java Streams API and Input/Output Streams). There are 2 types of async streams defined in the <code><a class="el" href="namespacewebcraft_1_1async_1_1io.html">webcraft::async::io</a></code> namespace: async readable streams and async writable streams.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Async readable streams</h2>
<p>The definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">concept </span>async_readable_stream = std::is_move_constructible_v&lt;Derived&gt; &amp;&amp; <span class="keyword">requires</span>(Derived &amp;stream) {</div>
<div class="line">    { stream.recv() } -&gt; std::same_as&lt;webcraft::async::task&lt;std::optional&lt;R&gt;&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Any type which models <code>async_readable_stream&lt;Derived, R&gt;</code> must have a function <code>recv()</code> which takes no arguments and returns a <code><a class="el" href="classwebcraft_1_1async_1_1task.html">webcraft::async::task</a>&lt;std::optional&lt;R&gt;&gt;</code>. Here <code>R</code> represents the type of value streamed to the client. The end of the stream is denoted when the result of the task is <code>std::nullopt</code>; subsequent calls to <code>recv()</code> will also result in <code>std::nullopt</code>.</p>
<p>There is also a buffered variant for streams which implement buffering internally:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">concept </span>async_buffered_readable_stream = async_readable_stream&lt;Derived, R&gt; &amp;&amp; <span class="keyword">requires</span>(Derived &amp;stream, std::span&lt;R&gt; buffer) {</div>
<div class="line">    { stream.recv(buffer) } -&gt; std::same_as&lt;webcraft::async::task&lt;std::size_t&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The buffered variant allows you to receive multiple objects at once from the stream. Internally, the regular <code>recv()</code> variant will either call the buffered variant with a buffer size of 1 or buffer values internally, so if values already exist in the internal queue, it only needs to pop them instead of waiting.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Async writable streams</h2>
<p>The definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">concept </span>async_writable_stream = std::is_move_constructible_v&lt;Derived&gt; &amp;&amp; <span class="keyword">requires</span>(Derived &amp;stream, R value) {</div>
<div class="line">    { stream.send(value) } -&gt; std::same_as&lt;webcraft::async::task&lt;bool&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Any type which models <code>async_writable_stream&lt;Derived, R&gt;</code> must have a function <code>send(R)</code> which takes an rvalue reference for R (to be moved into the stream) and returns a <code><a class="el" href="classwebcraft_1_1async_1_1task.html">webcraft::async::task</a>&lt;bool&gt;</code> indicating whether the value was successfully written.</p>
<p>There is also a buffered variant which allows you to write multiple objects at once (better for batching):</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">concept </span>async_buffered_writable_stream = async_writable_stream&lt;Derived, R&gt; &amp;&amp; <span class="keyword">requires</span>(Derived &amp;stream, std::span&lt;R&gt; buffer) {</div>
<div class="line">    { stream.send(buffer) } -&gt; std::same_as&lt;webcraft::async::task&lt;size_t&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p>This version accepts a span of values which will be written to the stream and returns the number of values actually written.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Async stream helpers</h2>
<p>For those who want to read and write multiple values without knowing whether the implementation provides buffering, we provide helper functions in the <code><a class="el" href="namespacewebcraft_1_1async_1_1io.html">webcraft::async::io</a></code> namespace:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, async_readable_stream&lt;R&gt; RStream, <span class="keywordtype">size_t</span> BufferSize&gt;</div>
<div class="line"><a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">webcraft::async::task&lt;std::size_t&gt;</a> recv(RStream &amp;stream, std::span&lt;R, BufferSize&gt; buffer);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, async_writable_stream&lt;R&gt; WStream, <span class="keywordtype">size_t</span> BufferSize&gt;</div>
<div class="line"><a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">webcraft::async::task&lt;size_t&gt;</a> send(WStream &amp;stream, std::span&lt;R, BufferSize&gt; buffer);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, async_readable_stream&lt;R&gt; RStream&gt;</div>
<div class="line"><a class="code hl_class" href="classcppcoro_1_1async__generator.html">cppcoro::async_generator&lt;R&gt;</a> to_async_generator(RStream &amp;&amp;stream);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;</div>
<div class="line">async_readable_stream&lt;R&gt; <span class="keyword">auto</span> to_readable_stream(<a class="code hl_class" href="classcppcoro_1_1async__generator.html">cppcoro::async_generator&lt;R&gt;</a> &amp;&amp;gen);</div>
<div class="ttc" id="aclasscppcoro_1_1async__generator_html"><div class="ttname"><a href="classcppcoro_1_1async__generator.html">cppcoro::async_generator</a></div><div class="ttdef"><b>Definition</b> async_generator.hpp:340</div></div>
<div class="ttc" id="aclasswebcraft_1_1async_1_1task_html"><div class="ttname"><a href="classwebcraft_1_1async_1_1task.html">webcraft::async::task</a></div><div class="ttdef"><b>Definition</b> task.hpp:102</div></div>
</div><!-- fragment --><p>The batched <code>recv()</code> and <code>send()</code> functions call the buffered stream variants if a buffered stream is passed, otherwise they call the non-buffered variants repeatedly until the span is filled or until no more data can be read/written.</p>
<p>The conversion to and from async generators are provided for readable streams since it enables powerful functional-style stream processing:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> fn = [](<span class="keywordtype">size_t</span> limit) -&gt; async_generator&lt;int&gt; {</div>
<div class="line">    <span class="keywordtype">size_t</span> count = 0;</div>
<div class="line">    <span class="keywordflow">while</span> (count &lt; limit) {</div>
<div class="line">        <span class="keyword">co_await</span> sleep(200ms);</div>
<div class="line">        <span class="keyword">co_yield</span> count++;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> rstream = <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#a65fdb2f3bc3e4af76fe30526dcb1e4b1">webcraft::async::io::to_readable_stream</a>(fn(10));</div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">auto</span> opt = <span class="keyword">co_await</span> rstream.recv()) {</div>
<div class="line">    handle(opt.value());</div>
<div class="line">}</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_html_a65fdb2f3bc3e4af76fe30526dcb1e4b1"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io.html#a65fdb2f3bc3e4af76fe30526dcb1e4b1">webcraft::async::io::to_readable_stream</a></div><div class="ttdeci">async_readable_stream&lt; R &gt; auto to_readable_stream(async_generator&lt; R &gt; &amp;&amp;gen)</div><div class="ttdef"><b>Definition</b> core.hpp:126</div></div>
</div><!-- fragment --><p>This will allow us to add a powerful set of adaptors onto async streams similar to the adaptors added with the ranges library onto iterables. From this, we can build powerful stream processing and pub/sub systems which can do a variety of processing without requiring manual stream processing.</p>
<p><b>Note:</b> All examples in this document use the <code><a class="el" href="namespacewebcraft_1_1async_1_1io.html">webcraft::async::io</a></code> namespace. For brevity, some code examples may omit the full namespace qualification, but all types and functions are within this namespace.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Channels</h2>
<p>Channels are a mechanism to transfer data from a publisher to a subscriber. The model implemented is MPSC (Multiple Producer, Single Consumer) since it only makes sense to deal with one event at a time. You can create an MPSC channel as shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [rstream, wstream] = webcraft::async::io::make_mpsc_channel&lt;int&gt;();</div>
</div><!-- fragment --><p>The type of <code>rstream</code> satisfies <code>async_readable_stream</code> and the type of <code>wstream</code> satisfies <code>async_writable_stream</code>. This effectively creates an asynchronous pipe. Concurrency is handled automatically - whenever <code>send()</code> is called on the writable stream, any waiting read operations are resumed.</p>
<p><b>NOTE: DO NOT pipe <code>rstream</code> into <code>wstream</code> as it will cause an infinite loop since all values received from read will be sent to write, which will trigger another read, creating a stack overflow.</b></p>
<p>Working with channels becomes useful for building highly scalable Publisher-Subscriber applications. Most microservices use message queues which internally use channels since they make working with event streams much easier. Channels are used internally for managing async socket I/O and async file I/O.</p>
<h1><a class="anchor" id="autotoc_md6"></a>
Async Readable Stream Adaptors</h1>
<p>Streams aren't really useful by themselves. Most of the time, we want to transform raw data into something useful. This is the idea of a <b>stream adaptor</b>. We take a readable stream of one data type, apply some operation (mapping, filtering, transforming), and get a stream of another data type.</p>
<p>Here's an example:</p>
<p>Suppose we want to group students into a map by letter grade (A for 80-100, B for 70-80, C for 60-70, D for 50-60), filter out failing students, and sort students within each group:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>student {</div>
<div class="line">    std::string name;</div>
<div class="line">    <span class="keywordtype">double</span> average;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The adaptor-based solution using WebCraft's stream adaptors:</p>
<div class="fragment"><div class="line">std::string average_to_grade(<span class="keywordtype">double</span> average) {</div>
<div class="line">    <span class="keywordflow">if</span> (average &gt;= 80.0) <span class="keywordflow">return</span> <span class="stringliteral">&quot;A&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (average &gt;= 70.0) <span class="keywordflow">return</span> <span class="stringliteral">&quot;B&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (average &gt;= 60.0) <span class="keywordflow">return</span> <span class="stringliteral">&quot;C&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;D&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">webcraft::async::task&lt;std::unordered_map&lt;std::string, std::vector&lt;student&gt;</a>&gt;&gt; </div>
<div class="line">get_student_grade_groupings(<a class="code hl_concept" href="conceptwebcraft_1_1async_1_1io_1_1async__readable__stream.html">webcraft::async::io::async_readable_stream&lt;student&gt;</a> <span class="keyword">auto</span> students) {</div>
<div class="line">    <span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html">webcraft::async::io::adaptors</a>;</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">co_return</span> <span class="keyword">co_await</span> (std::move(students) </div>
<div class="line">        | filter([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; st) { <span class="keywordflow">return</span> st.average &gt;= 50.0; })</div>
<div class="line">        | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#ac259db7916278ffc530b8c127be7a191">collect</a>(collectors::group_by([](<span class="keyword">const</span> student&amp; st) { </div>
<div class="line">            <span class="keywordflow">return</span> average_to_grade(st.average); </div>
<div class="line">          })));</div>
<div class="line">}</div>
<div class="ttc" id="aconceptwebcraft_1_1async_1_1io_1_1async__readable__stream_html"><div class="ttname"><a href="conceptwebcraft_1_1async_1_1io_1_1async__readable__stream.html">webcraft::async::io::async_readable_stream</a></div><div class="ttdef"><b>Definition</b> core.hpp:26</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html">webcraft::async::io::adaptors</a></div><div class="ttdef"><b>Definition</b> adaptors.hpp:19</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_ac259db7916278ffc530b8c127be7a191"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#ac259db7916278ffc530b8c127be7a191">webcraft::async::io::adaptors::collect</a></div><div class="ttdeci">auto collect(Collector &amp;&amp;collector_func)</div><div class="ttdef"><b>Definition</b> adaptors.hpp:116</div></div>
</div><!-- fragment --><p>This greatly reduces the amount of code and logic required. There are many other uses for async streams, especially when dealing with pub/sub systems.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Stream Adaptors Implementation</h2>
<p>All stream adaptors inherit from <code>async_readable_stream_adaptor</code>. The definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structwebcraft_1_1async_1_1io_1_1adaptors_1_1async__readable__stream__adaptor.html">async_readable_stream_adaptor</a></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">auto</span> operator|(async_readable_stream&lt;T&gt; <span class="keyword">auto</span> &amp;&amp;stream, Derived &amp;adaptor)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::invoke(adaptor, std::move(stream));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">auto</span> operator|(async_readable_stream&lt;T&gt; <span class="keyword">auto</span> &amp;&amp;stream, Derived &amp;&amp;adaptor)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> std::invoke(std::move(adaptor), std::forward&lt;<span class="keyword">decltype</span>(stream)&gt;(stream));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="astructwebcraft_1_1async_1_1io_1_1adaptors_1_1async__readable__stream__adaptor_html"><div class="ttname"><a href="structwebcraft_1_1async_1_1io_1_1adaptors_1_1async__readable__stream__adaptor.html">webcraft::async::io::adaptors::async_readable_stream_adaptor</a></div><div class="ttdef"><b>Definition</b> adaptors.hpp:23</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
Transform adaptor</h3>
<p>Definition:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InType, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> transform(Func &amp;&amp;fn) -&gt; <span class="comment">/* adaptor type */</span>;</div>
</div><!-- fragment --><p>Transform an existing async_readable_stream to another async_readable_stream. The function must have signature <code><a class="el" href="classcppcoro_1_1async__generator.html">cppcoro::async_generator</a>&lt;OutType&gt;(<a class="el" href="classcppcoro_1_1async__generator.html">cppcoro::async_generator</a>&lt;InType&gt;)</code>. Example:</p>
<div class="fragment"><div class="line">mock_readable_stream stream({1,2,3,4,5});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> new_stream = stream | webcraft::async::io::adaptors::transform&lt;int&gt;([](<a class="code hl_class" href="classcppcoro_1_1async__generator.html">cppcoro::async_generator&lt;int&gt;</a> gen) -&gt; <a class="code hl_class" href="classcppcoro_1_1async__generator.html">cppcoro::async_generator&lt;std::string&gt;</a> {</div>
<div class="line">    <a class="code hl_define" href="async__generator_8hpp.html#a4d7b3885bfafff1b24249b43416127d2">for_each_async</a>(value, gen, {</div>
<div class="line">        <span class="keyword">co_yield</span> std::to_string(value);</div>
<div class="line">        <span class="keyword">co_yield</span> std::to_string(value * 2); <span class="comment">// Duplicate and double</span></div>
<div class="line">    });</div>
<div class="line">});</div>
<div class="line"><span class="comment">// Result: [&quot;1&quot;, &quot;2&quot;, &quot;2&quot;, &quot;4&quot;, &quot;3&quot;, &quot;6&quot;, &quot;4&quot;, &quot;8&quot;, &quot;5&quot;, &quot;10&quot;]</span></div>
<div class="ttc" id="aasync__generator_8hpp_html_a4d7b3885bfafff1b24249b43416127d2"><div class="ttname"><a href="async__generator_8hpp.html#a4d7b3885bfafff1b24249b43416127d2">for_each_async</a></div><div class="ttdeci">#define for_each_async(value, gen, code)</div><div class="ttdef"><b>Definition</b> async_generator.hpp:422</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md9"></a>
Map adaptor</h3>
<p>Definition:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InType, <span class="keyword">typename</span> Func, <span class="keyword">typename</span> OutType = std::invoke_result_t&lt;Func, InType&gt;&gt;</div>
<div class="line"><span class="keyword">auto</span> map(Func &amp;&amp;fn) -&gt; <span class="comment">/* adaptor type */</span>;</div>
</div><!-- fragment --><p>Create a new readable stream with values mapped using the provided function. Example:</p>
<div class="fragment"><div class="line">mock_readable_stream stream({1,2,3,4,5});</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> new_stream = stream | webcraft::async::io::adaptors::map&lt;int&gt;([](<span class="keywordtype">int</span> value) {</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(value);</div>
<div class="line">});</div>
<div class="line"><span class="comment">// Result: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md10"></a>
Pipe adaptor</h3>
<p>Definition:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span> std::is_copy_assignable_v&lt;T&gt;</div>
<div class="line"><span class="keyword">auto</span> pipe(<a class="code hl_concept" href="conceptwebcraft_1_1async_1_1io_1_1async__writable__stream.html">webcraft::async::io::async_writable_stream&lt;T&gt;</a> <span class="keyword">auto</span> &amp;str) -&gt; <span class="comment">/* adaptor type */</span>;</div>
<div class="ttc" id="aconceptwebcraft_1_1async_1_1io_1_1async__writable__stream_html"><div class="ttname"><a href="conceptwebcraft_1_1async_1_1io_1_1async__writable__stream.html">webcraft::async::io::async_writable_stream</a></div><div class="ttdef"><b>Definition</b> core.hpp:36</div></div>
</div><!-- fragment --><p>Create a new readable stream that forwards read values to the provided writable stream. Example:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; rstream({1,2,3,4,5});</div>
<div class="line">mock_writable_stream&lt;int&gt; wstream;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> new_stream = rstream | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#ade46e7a4ed2b78a5081564b197a8ea57">webcraft::async::io::adaptors::pipe</a>(wstream);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">auto</span> opt = <span class="keyword">co_await</span> new_stream.recv()) {</div>
<div class="line">    assert(wstream.received_value(*opt));</div>
<div class="line">}</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_ade46e7a4ed2b78a5081564b197a8ea57"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#ade46e7a4ed2b78a5081564b197a8ea57">webcraft::async::io::adaptors::pipe</a></div><div class="ttdeci">auto pipe(async_writable_stream&lt; T &gt; auto &amp;str)</div><div class="ttdef"><b>Definition</b> adaptors.hpp:82</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
Filter adaptor</h3>
<p>Definition:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> filter(Func &amp;&amp;predicate) -&gt; <span class="comment">/* adaptor type */</span>;</div>
</div><!-- fragment --><p>Filter values in the stream based on a predicate. Example:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keyword">auto</span> new_stream = stream | webcraft::async::io::adaptors::filter&lt;int&gt;([](<span class="keywordtype">int</span> value) { </div>
<div class="line">    <span class="keywordflow">return</span> value % 2 == 0; </div>
<div class="line">});</div>
<div class="line"><span class="comment">// Result: [2,4]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md12"></a>
Limit adaptor</h3>
<p>Definition:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> limit(<span class="keywordtype">size_t</span> size) -&gt; <span class="comment">/* adaptor type */</span>;</div>
</div><!-- fragment --><p>Limit the number of values sent through the stream. Example:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keyword">auto</span> new_stream = stream | webcraft::async::io::adaptors::limit&lt;int&gt;(3);</div>
<div class="line"><span class="comment">// Result: [1,2,3]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md13"></a>
Skip adaptor</h3>
<p>Definition:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> skip(<span class="keywordtype">size_t</span> size) -&gt; <span class="comment">/* adaptor type */</span>;</div>
</div><!-- fragment --><p>Skip a number of values at the beginning of the stream. Example:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keyword">auto</span> new_stream = stream | webcraft::async::io::adaptors::skip&lt;int&gt;(2);</div>
<div class="line"><span class="comment">// Result: [3,4,5]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md14"></a>
Take while adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> take_while(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to take the values sent through the stream while the predicate defined by <code>Func</code> yields true. <code>Func</code> must have the following type signature <code>bool(const T&amp;)</code>. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line">async_readable_stream&lt;int&gt; <span class="keyword">auto</span> new_stream = stream | take_while([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i &lt; 2; });</div>
<div class="line"><span class="comment">// streams returned is [1,2]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md15"></a>
Drop while adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> drop_while(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to drop the values sent through the stream while the predicate defined by <code>Func</code> yields true. <code>Func</code> must have the following type signature <code>bool(const T&amp;)</code>. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line">async_readable_stream&lt;int&gt; <span class="keyword">auto</span> new_stream = stream | drop_while([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i &lt; 2; });</div>
<div class="line"><span class="comment">// streams returned is [3,4,5]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16"></a>
Collect adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> ToType, <span class="keyword">typename</span> StreamType&gt;</div>
<div class="line"><span class="keyword">concept </span>collector = std::is_invocable_r_v&lt;task&lt;ToType&gt;, Derived, <a class="code hl_class" href="classcppcoro_1_1async__generator.html">async_generator&lt;StreamType&gt;</a>&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ToType, <span class="keyword">typename</span> StreamType, collector&lt;ToType, StreamType&gt; Collector&gt;</div>
<div class="line"><span class="keyword">auto</span> collect(Collector &amp;&amp;collector_func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'll be able to convert the readable stream into something more tangible like another object or a <code>std::vector</code> of an object. This would be really useful especially for processing of REST requests when they give you a stream of bytes, you'll be able to collect it into a JSON object.</p>
<p>There are many ways to create your own collector, you can create your own, for example to convert a stream of bytes into a JSON object, or you can use some of the in-built ones:</p>
<ul>
<li>reduce</li>
<li>joining</li>
<li>to_vector</li>
<li>group_by</li>
</ul>
<h4><a class="anchor" id="autotoc_md17"></a>
Reduce collector</h4>
<p>Defined as shown:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> reduce(std::function&lt;T(T, T)&gt; &amp;&amp;func);</div>
</div><!-- fragment --><p>When collected, this will return a <code>task&lt;T&gt;</code> which can be awaited to give you the result. For example:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keywordtype">int</span> values = <span class="keyword">co_await</span> (stream | collect(collectors::reduce([](<span class="keywordtype">int</span> first, <span class="keywordtype">int</span> second) { <span class="keywordflow">return</span> first + second; })));</div>
<div class="line">assert(values == 15);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md18"></a>
Joining collector</h4>
<p>Defined as shown:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span> std::is_convertible_v&lt;T, std::string&gt;</div>
<div class="line"><span class="keyword">auto</span> joining(std::string separator = <span class="stringliteral">&quot;&quot;</span>, std::string prefix = <span class="stringliteral">&quot;&quot;</span>, std::string suffix = <span class="stringliteral">&quot;&quot;</span>)</div>
</div><!-- fragment --><p>When collected, this will return a <code>task&lt;std::string&gt;</code> which can be awaited to give you the result. For example:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>});</div>
<div class="line">std::string values = <span class="keyword">co_await</span> (stream | collect(collectors::joinin(<span class="stringliteral">&quot;,&quot;</span>)));</div>
<div class="line">assert(values == <span class="stringliteral">&quot;1,2,3,4,5&quot;</span>);</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md19"></a>
To Vector collector</h4>
<p>Defined as shown:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> to_vector();</div>
</div><!-- fragment --><p>When collected, this will return a <code>task&lt;std::vector&lt;T&gt;&gt;</code> which can be awaited to give you the result. For example:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line">std::vector&lt;int&gt; values = <span class="keyword">co_await</span> (stream | collect(collectors::to_vector()));</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; values.size(); i++) {</div>
<div class="line">    assert(values[i] == i + 1);</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md20"></a>
Group By collector</h4>
<p>Defined as shown:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> KeyType&gt;</div>
<div class="line"><span class="keyword">auto</span> group_by(std::function&lt;KeyType(<span class="keyword">const</span> T &amp;)&gt; key_function);</div>
</div><!-- fragment --><p>When collected, this will return a <code>task&lt;std::unordered_map&lt;KeyType, std::vector&lt;T&gt;&gt;&gt;</code> which can be awaited to give you the result. Example:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;std::string&gt; stream({<span class="stringliteral">&quot;AB&quot;</span>, <span class="stringliteral">&quot;BC&quot;</span>, <span class="stringliteral">&quot;AC&quot;</span>, <span class="stringliteral">&quot;BD&quot;</span>, <span class="stringliteral">&quot;CD&quot;</span>});</div>
<div class="line"><span class="keyword">auto</span> mapper = [](std::string value) -&gt; std::string { <span class="comment">// groups it by the first letter</span></div>
<div class="line">    <span class="keywordflow">return</span> std::string(value[0]); <span class="comment">// A* -&gt; A, B* -&gt; B</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a467323c557b8245b25c7cc5c6cd28e22">map</a> = <span class="keyword">co_await</span> (stream | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#ac259db7916278ffc530b8c127be7a191">collect</a>(collectors::group_by(mapper)));</div>
<div class="line"><span class="comment">//  returns a { {&quot;A&quot;, [&quot;AB&quot;,&quot;AC&quot;]}, {&quot;B&quot;, [&quot;BC&quot;,&quot;BD&quot;]}, {&quot;C&quot;, [&quot;CD&quot;]} }</span></div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_a467323c557b8245b25c7cc5c6cd28e22"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a467323c557b8245b25c7cc5c6cd28e22">webcraft::async::io::adaptors::map</a></div><div class="ttdeci">auto map(Func &amp;&amp;fn)</div><div class="ttdef"><b>Definition</b> adaptors.hpp:71</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21"></a>
Forward To adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">auto</span> forward_to(async_writable_stream&lt;T&gt; <span class="keyword">auto</span> &amp;stream) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'll be able to forward all objects coming from the readable stream into the output stream passed. When applied, the adaptor will return a <code>task&lt;void&gt;</code> which you can await for all the values to be sent into the stream. An example of this is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; rstream({1,2,3,4,5});</div>
<div class="line">mock_writable_stream&lt;int&gt; wstream;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">co_await</span> (rstream | forward_to(wstream));</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= 5; i++) {</div>
<div class="line">    assert(wstream.received(i));</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22"></a>
Min adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span> std::totally_ordered&lt;T&gt;</div>
<div class="line"><span class="keyword">auto</span> min() -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to find the minimum value sent through the stream. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keywordtype">int</span> min_value = <span class="keyword">co_await</span> (stream | min());</div>
<div class="line">assert(min_value == 1);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md23"></a>
Max adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span> std::totally_ordered&lt;T&gt;</div>
<div class="line"><span class="keyword">auto</span> max() -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to find the maximum value sent through the stream. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keywordtype">int</span> max_value = <span class="keyword">co_await</span> (stream | max());</div>
<div class="line">assert(max_value == 5);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md24"></a>
Sum adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">concept </span>closure_under_addition = <span class="keyword">requires</span>(T a, T b) {</div>
<div class="line">    { a + b } -&gt; std::convertible_to&lt;T&gt;;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">requires</span> closure_under_addition&lt;T&gt;</div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a01eae8f829e97817419aed01f5ad37dc">sum</a>() -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_a01eae8f829e97817419aed01f5ad37dc"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a01eae8f829e97817419aed01f5ad37dc">webcraft::async::io::adaptors::sum</a></div><div class="ttdeci">auto sum()</div><div class="ttdef"><b>Definition</b> adaptors.hpp:379</div></div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to find the sum of the values sent through the stream. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keywordtype">int</span> sum = <span class="keyword">co_await</span> (stream | sum());</div>
<div class="line">assert(sum == 15);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25"></a>
Find first adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> find_first(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to find the first value sent through the stream which matches the following predicate. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keywordtype">int</span> value = <span class="keyword">co_await</span> (stream | find_first([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(value == 2);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md26"></a>
Find last adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> find_last(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to find the last value sent through the stream which matches the following predicate. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream({1,2,3,4,5});</div>
<div class="line"><span class="keywordtype">int</span> value = <span class="keyword">co_await</span> (stream | find_last([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(value == 4);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md27"></a>
Any matches adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> any_matches(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to check if there are any values which match the predicate. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream_1({2,4,3,5});</div>
<div class="line">mock_readable_stream&lt;int&gt; stream_2({1,3,5});</div>
<div class="line"><span class="keywordtype">bool</span> check1 = <span class="keyword">co_await</span> (stream_1 | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#af103d36599b9cd7baf15f2c7e75e70b9">any_matches</a>([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(check1);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> check2 = <span class="keyword">co_await</span> (stream_2 | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#af103d36599b9cd7baf15f2c7e75e70b9">any_matches</a>([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(!check2);</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_af103d36599b9cd7baf15f2c7e75e70b9"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#af103d36599b9cd7baf15f2c7e75e70b9">webcraft::async::io::adaptors::any_matches</a></div><div class="ttdeci">auto any_matches(std::function&lt; bool(const T &amp;)&gt; &amp;&amp;predicate)</div><div class="ttdef"><b>Definition</b> adaptors.hpp:417</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md28"></a>
All matches adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> all_matches(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to check if all values which match the predicate. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream_1({2,4,6,8});</div>
<div class="line">mock_readable_stream&lt;int&gt; stream_2({2,4,6,7});</div>
<div class="line"><span class="keywordtype">bool</span> check1 = <span class="keyword">co_await</span> (stream_1 | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a1566ca935350435b72631ee11d574ee7">all_matches</a>([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(check1);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> check2 = <span class="keyword">co_await</span> (stream_2 | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a1566ca935350435b72631ee11d574ee7">all_matches</a>([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(!check2);</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_a1566ca935350435b72631ee11d574ee7"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#a1566ca935350435b72631ee11d574ee7">webcraft::async::io::adaptors::all_matches</a></div><div class="ttdeci">auto all_matches(std::function&lt; bool(const T &amp;)&gt; &amp;&amp;predicate)</div><div class="ttdef"><b>Definition</b> adaptors.hpp:432</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md29"></a>
None matches adaptor</h3>
<p>Definition is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Func&gt;</div>
<div class="line"><span class="keyword">auto</span> any_matches(Func&amp;&amp; func) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor, you'd be able to check if all values do not match the predicate. An example is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream_1({2,4,3,5});</div>
<div class="line">mock_readable_stream&lt;int&gt; stream_2({1,3,5});</div>
<div class="line"><span class="keywordtype">bool</span> check1 = <span class="keyword">co_await</span> (stream_1 | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#af0226fefe32175663e7ab469a785566c">none_matches</a>([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(!check1);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> check2 = <span class="keyword">co_await</span> (stream_2 | <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#af0226fefe32175663e7ab469a785566c">none_matches</a>([](<span class="keywordtype">int</span> value) { <span class="keywordflow">return</span> value % 2 == 0; }));</div>
<div class="line">assert(check2);</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1adaptors_html_af0226fefe32175663e7ab469a785566c"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1adaptors.html#af0226fefe32175663e7ab469a785566c">webcraft::async::io::adaptors::none_matches</a></div><div class="ttdeci">auto none_matches(std::function&lt; bool(const T &amp;)&gt; &amp;&amp;predicate)</div><div class="ttdef"><b>Definition</b> adaptors.hpp:447</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md30"></a>
Some of the adaptors are planned to be implemented in this framework:</h2>
<h3><a class="anchor" id="autotoc_md31"></a>
Sorted adaptor</h3>
<p>Definition is as shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">requires</span> std::totally_ordered&lt;T&gt;</div>
<div class="line"><span class="keyword">auto</span> sorted() -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">requires</span> std::totally_ordered&lt;R&gt;</div>
<div class="line"><span class="keyword">auto</span> sorted(std::function&lt;R(T)&gt; comparator) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor on a readable stream will create a new sorted readable stream from the old stream (all values will be sorted in the order specified). An example of the usage is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; values_1({5,1,3,6,4,2});</div>
<div class="line">async_readable_stream&lt;int&gt; <span class="keyword">auto</span> new_stream_1 = values_1 | sorted(); <span class="comment">// 1,2,3,4,5,6</span></div>
<div class="line"><span class="comment">// the new steam satisfies async_readable_stream&lt;1&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// another example</span></div>
<div class="line">mock_readable_stream&lt;std::pair&lt;int, std::string&gt;&gt; values_2({{5,<span class="stringliteral">&quot;5&quot;</span>}, {1,<span class="stringliteral">&quot;1&quot;</span>}, {<span class="stringliteral">&quot;3&quot;</span>,3}, {6,<span class="stringliteral">&quot;6&quot;</span>}, {4,<span class="stringliteral">&quot;4&quot;</span>},{2,<span class="stringliteral">&quot;2&quot;</span>}});</div>
<div class="line">async_readable_stream&lt;std::pair&lt;int, std::string&gt;&gt; <span class="keyword">auto</span> new_stream_2 = values_2 | sorted([](<span class="keyword">auto</span> value) { <span class="keywordflow">return</span> value.key; }); <span class="comment">// {1,&quot;1&quot;},{2,&quot;2&quot;},{3,&quot;3&quot;},{4,&quot;4&quot;},{5,&quot;5&quot;},{6,&quot;6&quot;}</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md32"></a>
Zip adaptor</h3>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">auto</span> zip_inner(async_readable_stream&lt;R&gt; str) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">auto</span> zip_left(async_readable_stream&lt;R&gt; str) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">auto</span> zip_right(async_readable_stream&lt;R&gt; str) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> R&gt;</div>
<div class="line"><span class="keyword">auto</span> zip_full(async_readable_stream&lt;R&gt; str) -&gt; std::is_derived_from&lt;async_readable_stream_adaptor&gt;;</div>
</div><!-- fragment --><p>Using this adaptor you'll be able to group 2 streams together into one. An example of this is shown below:</p>
<div class="fragment"><div class="line">mock_readable_stream&lt;int&gt; stream1({1,2,3,4,5});</div>
<div class="line">mock_readable_stream&lt;std::string&gt; stream2({<span class="stringliteral">&quot;1&quot;</span>,<span class="stringliteral">&quot;2&quot;</span>,<span class="stringliteral">&quot;3&quot;</span>,<span class="stringliteral">&quot;4&quot;</span>,<span class="stringliteral">&quot;5&quot;</span>});</div>
<div class="line"> </div>
<div class="line">async_readable_stream&lt;std::pair&lt;std::optional&lt;int&gt;, std::optional&lt;std::string&gt;&gt;&gt; <span class="keyword">auto</span> new_stream = stream1 | zip_full(stream2); <span class="comment">// {1,&quot;1&quot;},{2,&quot;2&quot;},{3,&quot;3&quot;},{4,&quot;4&quot;},{5,&quot;5&quot;},{6,&quot;6&quot;}</span></div>
<div class="line"><span class="comment">// the new steam satisfies async_readable_stream&lt;std::pair&lt;std::optional&lt;int&gt;, std::optional&lt;std::string&gt;&gt;&gt;</span></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md33"></a>
Async File I/O</h1>
<p>Async File I/O is handled differently on different platforms using the <code><a class="el" href="namespacewebcraft_1_1async_1_1io_1_1fs.html">webcraft::async::io::fs</a></code> namespace. The framework provides a unified interface while leveraging platform-specific optimizations:</p>
<h2><a class="anchor" id="autotoc_md34"></a>
File Operations Table</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Library   </th><th class="markdownTableHeadNone">Platforms Supported   </th><th class="markdownTableHeadNone">Special Create?   </th><th class="markdownTableHeadNone">Async Read?   </th><th class="markdownTableHeadNone">Async Write?   </th><th class="markdownTableHeadNone">Async Close?   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">IO Completion Ports   </td><td class="markdownTableBodyNone">Windows Only (<code>&lt;windows.h&gt;</code>)   </td><td class="markdownTableBodyNone">Synchronous but sets up async IO:<a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea"><code>CreateFileEx</code></a> + <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/createiocompletionport"><code>CreateIOCompletionPort</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile"><code>ReadFile</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile"><code>WriteFile</code></a>   </td><td class="markdownTableBodyNone">No Async Version. Just <a href="https://learn.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle"><code>CloseHandle</code></a>   </td><td class="markdownTableBodyNone"><b>Summary:</b> Synchronous create and close and async read and write but only for windows.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">io_uring   </td><td class="markdownTableBodyNone">Linux Only (<code>&lt;liburing.h&gt;</code>)   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_open.3.html"><code>io_uring_prep_open</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_read.3.html"><code>io_uring_prep_read</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_write.3.html"><code>io_uring_prep_write</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_close.3.html"><code>io_uring_prep_close</code></a>   </td><td class="markdownTableBodyNone"><b>Summary:</b> Has async support for all file functions but only for linux    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kqueue + aio   </td><td class="markdownTableBodyNone">Pure BSD-based systems like FreeBSD (<code>&lt;sys/event.h&gt;</code> + <code>&lt;aio.h&gt;</code>)   </td><td class="markdownTableBodyNone">Synchronous: Use POSIX<code>open</code>   </td><td class="markdownTableBodyNone">Use<code>aio_read</code> with kqueue   </td><td class="markdownTableBodyNone">Use<code>aio_write</code> with   </td><td class="markdownTableBodyNone">Synchronous: Use <code>close</code>   </td><td class="markdownTableBodyNone"><b>NOTE: Make sure when the kqueue result has returned to call <code>aio_return</code>.</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread pool   </td><td class="markdownTableBodyNone">MacOS or any other system which does not support Async File I/O natively   </td><td class="markdownTableBodyNone">Synchronous: Use POSIX<code>open</code>   </td><td class="markdownTableBodyNone">Use<code>read</code> on thread pool   </td><td class="markdownTableBodyNone">Use<code>write</code> on thread   </td><td class="markdownTableBodyNone">Synchronous: Use<code>close</code>   </td><td class="markdownTableBodyNone">Use a thread pool    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">GCD   </td><td class="markdownTableBodyNone">MacOS Only - plan on implementing this in the next PR   </td><td class="markdownTableBodyNone">tbd   </td><td class="markdownTableBodyNone">tdb   </td><td class="markdownTableBodyNone">tdb   </td><td class="markdownTableBodyNone">tdb   </td><td class="markdownTableBodyNone">Need to look into this more   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md35"></a>
Async Socket I/O</h1>
<p>Async Socket I/O is handled differently on different platforms using the <code><a class="el" href="namespacewebcraft_1_1async_1_1io_1_1socket.html">webcraft::async::io::socket</a></code> namespace.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
TCP Sockets Table</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Library   </th><th class="markdownTableHeadNone">Platforms Supported   </th><th class="markdownTableHeadNone">Special Create?   </th><th class="markdownTableHeadNone">Async Connect?   </th><th class="markdownTableHeadNone">Async Read?   </th><th class="markdownTableHeadNone">Async Write?   </th><th class="markdownTableHeadNone">Async Close?   </th><th class="markdownTableHeadNone">Async Shutdown?   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">io_uring   </td><td class="markdownTableBodyNone">Linux   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_socket.3.html"><code>io_uring_prep_socket</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_connect.3.html"><code>io_uring_prep_connect</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_read.3.html"><code>io_uring_prep_read</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_write.3.html"><code>io_uring_prep_write</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_close.3.html"><code>io_uring_prep_close</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_shutdown.3.html"><code>io_uring_prep_shutdown</code></a>   </td><td class="markdownTableBodyNone"><b>NOTE: All the functions are async just linux only.</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">IOCP   </td><td class="markdownTableBodyNone">Windows   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket"><code>socket</code></a> + <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/createiocompletionport"><code>CreateIOCompletionPort</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_connectex"><code>ConnectEx</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-gb/windows/win32/api/winsock2/nf-winsock2-wsarecv"><code>WSARecv</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-gb/windows/win32/api/winsock2/nf-winsock2-wsasend"><code>WSASend</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-closesocket"><code>closesocket</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-shutdown"><code>shutdown</code></a>   </td><td class="markdownTableBodyNone"><b>NOTE: A call to <code>bind()</code> must be made before calling ConnectEx otherwise socket will be invalid.</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kqueue   </td><td class="markdownTableBodyNone">BSD based systems   </td><td class="markdownTableBodyNone"><code>socket</code>   </td><td class="markdownTableBodyNone"><code>connect</code>   </td><td class="markdownTableBodyNone"><code>read</code>   </td><td class="markdownTableBodyNone"><code>write</code>   </td><td class="markdownTableBodyNone"><code>close</code>   </td><td class="markdownTableBodyNone"><code>shutdown</code>   </td><td class="markdownTableBodyNone"><b>NOTE: It seems like it's all just synchronous API calls but kqueue lets us know when to call what under the hood. Kqueue will be our notification agent and we'll use channels and other forms of asynchronous delivery to let us know when to resume. Refer to the kqueue example below.</b>   </td></tr>
</table>
<p>Some docs:</p><ul>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_connectex">https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_connectex</a></li>
<li><a href="https://gist.github.com/joeyadams/4158972">https://gist.github.com/joeyadams/4158972</a></li>
<li><a href="https://stackoverflow.com/questions/13598530/connectex-requires-the-socket-to-be-initially-bound-but-to-what">https://stackoverflow.com/questions/13598530/connectex-requires-the-socket-to-be-initially-bound-but-to-what</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md37"></a>
TCP Listeners Table</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Library   </th><th class="markdownTableHeadNone">Platforms Supported   </th><th class="markdownTableHeadNone">Special Create?   </th><th class="markdownTableHeadNone">Async Bind?   </th><th class="markdownTableHeadNone">Async Listen?   </th><th class="markdownTableHeadNone">Async Accept   </th><th class="markdownTableHeadNone">Async Close?   </th><th class="markdownTableHeadNone">Notes    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">io_uring   </td><td class="markdownTableBodyNone">Linux   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_socket.3.html"><code>io_uring_prep_socket</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_bind.3.html"><code>io_uring_prep_bind</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_listen.3.html"><code>io_uring_prep_listen</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_accept.3.html"><code>io_uring_prep_accept</code></a>   </td><td class="markdownTableBodyNone"><a href="https://man7.org/linux/man-pages/man3/io_uring_prep_close.3.html"><code>io_uring_prep_close</code></a>   </td><td class="markdownTableBodyNone"><b>NOTE: All the functions are async just linux only.</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">IOCP   </td><td class="markdownTableBodyNone">Windows   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket"><code>socket</code></a> + <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/createiocompletionport"><code>CreateIOCompletionPort</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-bind"><code>bind</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen"><code>listen</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-gb/windows/win32/api/mswsock/nf-mswsock-acceptex"><code>AcceptEx</code></a>   </td><td class="markdownTableBodyNone"><a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-closesocket"><code>closesocket</code></a>   </td><td class="markdownTableBodyNone"></td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">kqueue   </td><td class="markdownTableBodyNone">BSD based systems   </td><td class="markdownTableBodyNone"><code>socket</code>   </td><td class="markdownTableBodyNone"><code>bind</code>   </td><td class="markdownTableBodyNone"><code>listen</code>   </td><td class="markdownTableBodyNone"><code>accept</code>   </td><td class="markdownTableBodyNone"><code>close</code>   </td><td class="markdownTableBodyNone"><b>NOTE: It seems like it's all just synchronous API calls but kqueue lets us know when to call what under the hood. Kqueue will be our notification agent and we'll use channels and other forms of asynchronous delivery to let us know when to resume. Refer to the kqueue example below.</b>   </td></tr>
</table>
<p>Examples:</p><ul>
<li><a href="https://learn.microsoft.com/en-gb/windows/win32/api/mswsock/nf-mswsock-acceptex#example-code">https://learn.microsoft.com/en-gb/windows/win32/api/mswsock/nf-mswsock-acceptex#example-code</a></li>
<li><a href="https://gist.github.com/josephg/6c078a241b0e9e538ac04ef28be6e787">https://gist.github.com/josephg/6c078a241b0e9e538ac04ef28be6e787</a></li>
<li>KQUEUE Example: <a href="https://dev.to/frevib/a-tcp-server-with-kqueue-527">https://dev.to/frevib/a-tcp-server-with-kqueue-527</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md38"></a>
Planned implementation:</h1>
<p>Async Read &amp; Async Write will be based on what's in the <b>Async Read</b> and <b>Async Write</b> columns. Closing will still happen with RAII (which would be a synchronous close on everything but linux) but on linux we'll send a fire-and-forget request with <code>io_uring_prep_close</code>. For async creation it can either be with synchronous or asynchronous, the bottleneck wouldn't be too big of an issue.</p>
<p>This is the following specification for using the <b>Async File I/O</b> API: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>detail</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>file_descriptor</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        std::ios_base::openmode mode;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        file_descriptor(std::ios_base::openmode mode) : mode(mode) {}</div>
<div class="line">        <span class="keyword">virtual</span> ~file_descriptor() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// virtual because we want to allow platform specific implementation</span></div>
<div class="line">        <span class="keyword">virtual</span> <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;size_t&gt;</a> read(std::span&lt;char&gt; buffer) = 0;  <span class="comment">// internally should check if openmode is for read</span></div>
<div class="line">        <span class="keyword">virtual</span> <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;size_t&gt;</a> write(std::span&lt;char&gt; buffer) = 0; <span class="comment">// internally should check if openmode is for write or append</span></div>
<div class="line">        <span class="keyword">virtual</span> <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;void&gt;</a> close() = 0;                         <span class="comment">// will spawn a fire and forget task (essentially use async apis but provide null callback)</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;std::shared_ptr&lt;file_descriptor&gt;</a>&gt; make_file_descriptor(std::filesystem::path p, std::ios_base::openmode mode);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>file_stream</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line">        std::shared_ptr&lt;file_descriptor&gt; fd;</div>
<div class="line">        std::atomic&lt;bool&gt; closed{<span class="keyword">false</span>};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">explicit</span> file_stream(std::shared_ptr&lt;file_descriptor&gt; fd) : fd(std::move(fd)) {}</div>
<div class="line">        <span class="keyword">virtual</span> ~file_stream() noexcept</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (fd)</div>
<div class="line">                <a class="code hl_function" href="namespacewebcraft_1_1async.html#a367712ca561ac34d7d28f495a6462c09">sync_wait</a>(close());</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;void&gt;</a> close() noexcept</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">bool</span> expected = <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">if</span> (closed.compare_exchange_strong(expected, <span class="keyword">true</span>, std::memory_order_acq_rel))</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">co_await</span> fd-&gt;close();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>file_rstream : <span class="keyword">public</span> detail::file_stream</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    file_rstream(std::shared_ptr&lt;detail::file_descriptor&gt; fd) : detail::file_stream(std::move(fd)) {}</div>
<div class="line">    ~file_rstream() noexcept = default;</div>
<div class="line"> </div>
<div class="line">    file_rstream(file_rstream &amp;&amp;) noexcept = default;</div>
<div class="line">    file_rstream &amp;operator=(file_rstream &amp;&amp;) noexcept = default;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task</a>&lt;<span class="keywordtype">size_t</span>&gt; recv(std::span&lt;<span class="keywordtype">char</span>&gt; buffer)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> fd-&gt;read(buffer);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;char&gt;</a> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#aaaf5c2dda44d2ea9c9518aa85bf729c1">recv</a>()</div>
<div class="line">    {</div>
<div class="line">        std::array&lt;char, 1&gt; buf;</div>
<div class="line">        <span class="keyword">co_await</span> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#aaaf5c2dda44d2ea9c9518aa85bf729c1">recv</a>(buf);</div>
<div class="line">        <span class="keyword">co_return</span> buf[0];</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(async_readable_stream&lt;file_rstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_buffered_readable_stream&lt;file_rstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_closeable_stream&lt;file_rstream, char&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>file_wstream : <span class="keyword">public</span> detail::file_stream</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">explicit</span> file_wstream(std::shared_ptr&lt;file_descriptor&gt; fd) : detail::file_stream(std::move(fd)) {}</div>
<div class="line">    ~file_wstream() noexcept = default;</div>
<div class="line"> </div>
<div class="line">    file_wstream(file_wstream &amp;&amp;) noexcept = default;</div>
<div class="line">    file_wstream &amp;operator=(file_wstream &amp;&amp;) noexcept = default;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task</a>&lt;<span class="keywordtype">size_t</span>&gt; send(std::span&lt;<span class="keywordtype">char</span>&gt; buffer)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> fd-&gt;write(buffer);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;bool&gt;</a> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#af2b81544adcc4ba129f31b5797a43670">send</a>(<span class="keywordtype">char</span> b)</div>
<div class="line">    {</div>
<div class="line">        std::array&lt;char, 1&gt; buf;</div>
<div class="line">        buf[0] = b;</div>
<div class="line">        <span class="keyword">co_await</span> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#af2b81544adcc4ba129f31b5797a43670">send</a>(buf);</div>
<div class="line">        <span class="keyword">co_return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(async_writable_stream&lt;file_wstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_buffered_writable_stream&lt;file_wstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_closeable_stream&lt;file_wstream, char&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>file</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::filesystem::path p;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    file(std::filesystem::path p) : p(std::move(p)) {}</div>
<div class="line">    ~file() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;file_rstream&gt;</a> open_readable_stream()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> descriptor = <span class="keyword">co_await</span> detail::make_file_descriptor(p, std::ios_base::in);</div>
<div class="line">        <span class="keyword">co_return</span> file_rstream(descriptor);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;file_wstream&gt;</a> open_writable_stream(<span class="keywordtype">bool</span> append)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> descriptor = <span class="keyword">co_await</span> detail::make_file_descriptor(p, append ? std::ios_base::app : std::ios_base::out);</div>
<div class="line">        <span class="keyword">co_return</span> file_wstream(std::move(descriptor));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">const</span> std::filesystem::path get_path()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> p; }</div>
<div class="line">    <span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="keyword">const</span> std::filesystem::path &amp;() <span class="keyword">const</span> { <span class="keywordflow">return</span> p; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">file <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1fs.html#a8d8e45ed576cda72f736cd9e66952947">make_file</a>(std::filesystem::path p)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> file(p);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1fs_html_a8d8e45ed576cda72f736cd9e66952947"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1fs.html#a8d8e45ed576cda72f736cd9e66952947">webcraft::async::io::fs::make_file</a></div><div class="ttdeci">file make_file(std::filesystem::path p)</div><div class="ttdef"><b>Definition</b> fs.hpp:159</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_html_aaaf5c2dda44d2ea9c9518aa85bf729c1"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io.html#aaaf5c2dda44d2ea9c9518aa85bf729c1">webcraft::async::io::recv</a></div><div class="ttdeci">auto recv(async_readable_stream&lt; R &gt; auto &amp;stream)</div><div class="ttdef"><b>Definition</b> core.hpp:51</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_html_af2b81544adcc4ba129f31b5797a43670"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io.html#af2b81544adcc4ba129f31b5797a43670">webcraft::async::io::send</a></div><div class="ttdeci">task&lt; bool &gt; send(WStream &amp;stream, R &amp;&amp;value)</div><div class="ttdef"><b>Definition</b> core.hpp:81</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_html_a367712ca561ac34d7d28f495a6462c09"><div class="ttname"><a href="namespacewebcraft_1_1async.html#a367712ca561ac34d7d28f495a6462c09">webcraft::async::sync_wait</a></div><div class="ttdeci">awaitable_resume_t&lt; T &gt; sync_wait(T &amp;&amp;awaitable)</div><div class="ttdef"><b>Definition</b> sync_wait.hpp:16</div></div>
</div><!-- fragment --><p>This is the following specification for using the <b>Async TCP Socket and Listener I/O</b> API: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>connection_info</div>
<div class="line">{</div>
<div class="line">    std::string host;</div>
<div class="line">    uint16_t port;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum class</span> socket_stream_mode</div>
<div class="line">{</div>
<div class="line">    READ,</div>
<div class="line">    WRITE</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>detail</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>tcp_descriptor_base</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        tcp_descriptor_base() = <span class="keywordflow">default</span>;</div>
<div class="line">        <span class="keyword">virtual</span> ~tcp_descriptor_base() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">virtual</span> <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;void&gt;</a> close() = 0; <span class="comment">// Close the socket</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>tcp_socket_descriptor : <span class="keyword">public</span> tcp_descriptor_base</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        tcp_socket_descriptor() = <span class="keywordflow">default</span>;</div>
<div class="line">        <span class="keyword">virtual</span> ~tcp_socket_descriptor() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">virtual</span> <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;void&gt;</a> connect(<span class="keyword">const</span> connection_info &amp;info) = 0;  <span class="comment">// Connect to a server</span></div>
<div class="line">        <span class="keyword">virtual</span> <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;size_t&gt;</a> read(std::span&lt;char&gt; buffer) = 0;        <span class="comment">// Read data from the socket</span></div>
<div class="line">        <span class="keyword">virtual</span> <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;size_t&gt;</a> write(std::span&lt;const char&gt; buffer) = 0; <span class="comment">// Write data to the socket</span></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code hl_function" href="namespacewebcraft_1_1async.html#a32cc887e48f12d360656c6f023977a2d">shutdown</a>(socket_stream_mode mode) = 0;     <span class="comment">// Shutdown the socket</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>tcp_listener_descriptor : <span class="keyword">public</span> tcp_descriptor_base</div>
<div class="line">    {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        tcp_listener_descriptor() = <span class="keywordflow">default</span>;</div>
<div class="line">        <span class="keyword">virtual</span> ~tcp_listener_descriptor() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> bind(<span class="keyword">const</span> connection_info &amp;info) = 0;          <span class="comment">// Bind the listener to an address</span></div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> listen(<span class="keywordtype">int</span> backlog) = 0;                        <span class="comment">// Start listening for incoming connections</span></div>
<div class="line">        <span class="keyword">virtual</span> <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;std::unique_ptr&lt;tcp_socket_descriptor&gt;</a>&gt; accept() = 0; <span class="comment">// Accept a new connection</span></div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;tcp_socket_descriptor&gt; make_tcp_socket_descriptor();</div>
<div class="line">    std::shared_ptr&lt;tcp_listener_descriptor&gt; make_tcp_listener_descriptor();</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>tcp_rstream</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;detail::tcp_socket_descriptor&gt; descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    tcp_rstream(std::shared_ptr&lt;detail::tcp_socket_descriptor&gt; desc) : descriptor(std::move(desc)) {}</div>
<div class="line">    ~tcp_rstream() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;size_t&gt;</a> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#aaaf5c2dda44d2ea9c9518aa85bf729c1">recv</a>(std::span&lt;char&gt; buffer)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> descriptor-&gt;read(buffer);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;char&gt;</a> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#aaaf5c2dda44d2ea9c9518aa85bf729c1">recv</a>()</div>
<div class="line">    {</div>
<div class="line">        std::array&lt;char, 1&gt; buf;</div>
<div class="line">        <span class="keyword">co_await</span> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#aaaf5c2dda44d2ea9c9518aa85bf729c1">recv</a>(buf);</div>
<div class="line">        <span class="keyword">co_return</span> buf[0];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;void&gt;</a> close()</div>
<div class="line">    {</div>
<div class="line">        descriptor-&gt;shutdown(socket_stream_mode::READ);</div>
<div class="line">        <span class="keyword">co_return</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(async_writable_stream&lt;tcp_rstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_buffered_writable_stream&lt;tcp_rstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_closeable_stream&lt;tcp_rstream, char&gt;);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>tcp_wstream</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;detail::tcp_socket_descriptor&gt; descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    tcp_wstream(std::shared_ptr&lt;detail::tcp_socket_descriptor&gt; desc) : descriptor(std::move(desc)) {}</div>
<div class="line">    ~tcp_wstream() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;size_t&gt;</a> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#af2b81544adcc4ba129f31b5797a43670">send</a>(std::span&lt;const char&gt; buffer)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> descriptor-&gt;write(buffer);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;bool&gt;</a> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#af2b81544adcc4ba129f31b5797a43670">send</a>(<span class="keywordtype">char</span> b)</div>
<div class="line">    {</div>
<div class="line">        std::array&lt;char, 1&gt; buf;</div>
<div class="line">        buf[0] = b;</div>
<div class="line">        <span class="keyword">co_await</span> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io.html#af2b81544adcc4ba129f31b5797a43670">send</a>(buf);</div>
<div class="line">        <span class="keyword">co_return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;void&gt;</a> close()</div>
<div class="line">    {</div>
<div class="line">        descriptor-&gt;shutdown(socket_stream_mode::WRITE);</div>
<div class="line">        <span class="keyword">co_return</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static_assert</span>(async_writable_stream&lt;tcp_wstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_buffered_writable_stream&lt;tcp_wstream, char&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(async_closeable_stream&lt;tcp_wstream, char&gt;);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>tcp_socket</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;detail::tcp_socket_descriptor&gt; descriptor;</div>
<div class="line">    tcp_rstream read_stream;</div>
<div class="line">    tcp_wstream write_stream;</div>
<div class="line">    <span class="keywordtype">bool</span> read_shutdown{<span class="keyword">false</span>};</div>
<div class="line">    <span class="keywordtype">bool</span> write_shutdown{<span class="keyword">false</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    tcp_socket(std::shared_ptr&lt;detail::tcp_socket_descriptor&gt; desc) : descriptor(desc), read_stream(descriptor), write_stream(descriptor)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ~tcp_socket()</div>
<div class="line">    {</div>
<div class="line">        <a class="code hl_function" href="namespacewebcraft_1_1async.html#aa32214c386ded164491af1d325b36e11">fire_and_forget</a>(close());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    tcp_socket(tcp_socket &amp;&amp;other) noexcept</div>
<div class="line">        : descriptor(std::exchange(other.descriptor, <span class="keyword">nullptr</span>)),</div>
<div class="line">            read_stream(std::move(other.read_stream)),</div>
<div class="line">            write_stream(std::move(other.write_stream))</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    tcp_socket &amp;operator=(tcp_socket &amp;&amp;other) <span class="keyword">noexcept</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;other)</div>
<div class="line">        {</div>
<div class="line">            descriptor = std::exchange(other.descriptor, <span class="keyword">nullptr</span>);</div>
<div class="line">            read_stream = std::move(other.read_stream);</div>
<div class="line">            write_stream = std::move(other.write_stream);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;void&gt;</a> connect(<span class="keyword">const</span> connection_info &amp;info)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!descriptor)</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Descriptor is null&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">co_await</span> descriptor-&gt;connect(info);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    tcp_rstream &amp;get_readable_stream()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!descriptor)</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Descriptor is null&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> read_stream;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    tcp_wstream &amp;get_writable_stream()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!descriptor)</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Descriptor is null&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> write_stream;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> shutdown_channel(socket_stream_mode mode)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (mode == socket_stream_mode::READ &amp;&amp; !read_shutdown)</div>
<div class="line">        {</div>
<div class="line">            descriptor-&gt;shutdown(socket_stream_mode::READ);</div>
<div class="line">            this-&gt;read_shutdown = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mode == socket_stream_mode::WRITE &amp;&amp; !write_shutdown)</div>
<div class="line">        {</div>
<div class="line">            descriptor-&gt;shutdown(socket_stream_mode::WRITE);</div>
<div class="line">            this-&gt;write_shutdown = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;void&gt;</a> close()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (descriptor)</div>
<div class="line">        {</div>
<div class="line">            shutdown_channel(socket_stream_mode::READ);</div>
<div class="line">            shutdown_channel(socket_stream_mode::WRITE);</div>
<div class="line">            <span class="keyword">co_await</span> descriptor-&gt;close();</div>
<div class="line">            descriptor.reset();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> std::string get_remote_host()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> descriptor-&gt;get_remote_host();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> uint16_t get_remote_port()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> descriptor-&gt;get_remote_port();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>tcp_listener</div>
<div class="line">{</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::shared_ptr&lt;detail::tcp_listener_descriptor&gt; descriptor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    tcp_listener(std::shared_ptr&lt;detail::tcp_listener_descriptor&gt; desc) : descriptor(std::move(desc)) {}</div>
<div class="line">    ~tcp_listener()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (descriptor)</div>
<div class="line">        {</div>
<div class="line">            <a class="code hl_function" href="namespacewebcraft_1_1async.html#aa32214c386ded164491af1d325b36e11">fire_and_forget</a>(descriptor-&gt;close());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> bind(<span class="keyword">const</span> connection_info &amp;info)</div>
<div class="line">    {</div>
<div class="line">        descriptor-&gt;bind(info);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> listen(<span class="keywordtype">int</span> backlog)</div>
<div class="line">    {</div>
<div class="line">        descriptor-&gt;listen(backlog);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;tcp_socket&gt;</a> accept()</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">co_return</span> <span class="keyword">co_await</span> descriptor-&gt;accept();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;tcp_socket&gt;</a> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1socket.html#a482e358e1f53606e06109999484276b3">make_tcp_socket</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> descriptor = <span class="keyword">co_await</span> detail::make_tcp_socket_descriptor();</div>
<div class="line">    <span class="keyword">co_return</span> tcp_socket(std::move(descriptor));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classwebcraft_1_1async_1_1task.html">task&lt;tcp_listener&gt;</a> <a class="code hl_function" href="namespacewebcraft_1_1async_1_1io_1_1socket.html#a861e0c806d177e378bae72a3cfb5f0e2">make_tcp_listener</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> descriptor = <span class="keyword">co_await</span> detail::make_tcp_listener_descriptor();</div>
<div class="line">    <span class="keyword">co_return</span> tcp_listener(std::move(descriptor));</div>
<div class="line">}</div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1socket_html_a482e358e1f53606e06109999484276b3"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1socket.html#a482e358e1f53606e06109999484276b3">webcraft::async::io::socket::make_tcp_socket</a></div><div class="ttdeci">tcp_socket make_tcp_socket()</div><div class="ttdef"><b>Definition</b> socket.hpp:288</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_1_1io_1_1socket_html_a861e0c806d177e378bae72a3cfb5f0e2"><div class="ttname"><a href="namespacewebcraft_1_1async_1_1io_1_1socket.html#a861e0c806d177e378bae72a3cfb5f0e2">webcraft::async::io::socket::make_tcp_listener</a></div><div class="ttdeci">tcp_listener make_tcp_listener()</div><div class="ttdef"><b>Definition</b> socket.hpp:293</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_html_a32cc887e48f12d360656c6f023977a2d"><div class="ttname"><a href="namespacewebcraft_1_1async.html#a32cc887e48f12d360656c6f023977a2d">webcraft::async::shutdown</a></div><div class="ttdeci">task&lt; void &gt; shutdown()</div><div class="ttdef"><b>Definition</b> runtime.hpp:245</div></div>
<div class="ttc" id="anamespacewebcraft_1_1async_html_aa32214c386ded164491af1d325b36e11"><div class="ttname"><a href="namespacewebcraft_1_1async.html#aa32214c386ded164491af1d325b36e11">webcraft::async::fire_and_forget</a></div><div class="ttdeci">fire_and_forget_task fire_and_forget(task&lt; void &gt; t)</div><div class="ttdef"><b>Definition</b> fire_and_forget_task.hpp:33</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md39"></a>
Implementation Details</h1>
<p>The WebCraft framework implements platform-specific optimizations through:</p>
<ul>
<li><code>webcraft::async::io::fs::detail::make_file_descriptor()</code> - Creates platform-optimized file descriptors</li>
<li><code>webcraft::async::io::socket::detail::make_tcp_socket_descriptor()</code> - Creates platform-optimized TCP socket descriptors <br  />
</li>
<li><code>webcraft::async::io::socket::detail::make_tcp_listener_descriptor()</code> - Creates platform-optimized TCP listener descriptors</li>
</ul>
<p>All functions return <code>std::shared_ptr</code> to the appropriate descriptor types, providing automatic resource management and platform abstraction. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
