\chapter{Web Specification}
\hypertarget{md_include_2webcraft_2web_2README}{}\label{md_include_2webcraft_2web_2README}\index{Web Specification@{Web Specification}}
\label{md_include_2webcraft_2web_2README_autotoc_md59}%
\Hypertarget{md_include_2webcraft_2web_2README_autotoc_md59}%
 \hypertarget{md_include_2webcraft_2web_2README_autotoc_md60}{}\doxysection{\texorpdfstring{Introduction}{Introduction}}\label{md_include_2webcraft_2web_2README_autotoc_md60}
The backbone of web modules defined here are based off of the async runtime and async io modules.

{\bfseries{NOTE\+: You\textquotesingle{}ll notice in this documentation, I\textquotesingle{}m mentioning the usage of HTTP/3 and UDP protocol even though my current codebase does not have a specification or support for UDP. That would be a newer addition to the framework, an issue for it will be made and either I or (an) open source developer(s) will be working on getting that done with async support.}}\hypertarget{md_include_2webcraft_2web_2README_autotoc_md61}{}\doxysection{\texorpdfstring{Implementation}{Implementation}}\label{md_include_2webcraft_2web_2README_autotoc_md61}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md62}{}\doxysection{\texorpdfstring{namespace webcraft\+::web\+::core}{namespace webcraft::web::core}}\label{md_include_2webcraft_2web_2README_autotoc_md62}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md63}{}\doxysubsection{\texorpdfstring{message}{message}}\label{md_include_2webcraft_2web_2README_autotoc_md63}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using\ }message\ =\ std::span<const\ char>;}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md64}{}\doxysubsection{\texorpdfstring{web\+\_\+read\+\_\+stream}{web\_read\_stream}}\label{md_include_2webcraft_2web_2README_autotoc_md64}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }web\_read\_stream\ =\ async\_buffered\_readable\_stream<T,\ char>\ \&\&\ async\_closable\_stream<T>;}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md65}{}\doxysubsection{\texorpdfstring{web\+\_\+write\+\_\+stream}{web\_write\_stream}}\label{md_include_2webcraft_2web_2README_autotoc_md65}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }web\_write\_stream\ =\ async\_buffered\_writable\_stream<T,\ char>\ \&\&\ async\_closable\_stream<T>;}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md66}{}\doxysubsection{\texorpdfstring{http\+\_\+method}{http\_method}}\label{md_include_2webcraft_2web_2README_autotoc_md66}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{enum\ class}\ http\_method}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ GET,}
\DoxyCodeLine{\ \ \ \ POST,}
\DoxyCodeLine{\ \ \ \ PUT,}
\DoxyCodeLine{\ \ \ \ DELETE,}
\DoxyCodeLine{\ \ \ \ OPTIONS,}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md67}{}\doxysubsection{\texorpdfstring{http\+\_\+response\+\_\+code}{http\_response\_code}}\label{md_include_2webcraft_2web_2README_autotoc_md67}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{enum\ class}\ http\_code}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ }}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ success\ codes}}
\DoxyCodeLine{\ \ \ \ SUCCESS=200,}
\DoxyCodeLine{\ \ \ \ NO\_CONTENT=201}
\DoxyCodeLine{\ \ \ \ ...}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ redirect\ code}}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//}}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md68}{}\doxysubsection{\texorpdfstring{payload\+\_\+dispatcher}{payload\_dispatcher}}\label{md_include_2webcraft_2web_2README_autotoc_md68}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }payload\_dispatcher\ =\ \textcolor{keyword}{requires}(T\ t1,\ T\&\ t2,\ T\&\&\ t3,\ web\_write\_stream\&\ stream)\ \{}
\DoxyCodeLine{\ \ \ \ \{\ t1(stream)\ \}\ -\/>\ std::same\_as<task<void>>;}
\DoxyCodeLine{\ \ \ \ \{\ t2(stream)\ \}\ -\/>\ std::same\_as<task<void>>;}
\DoxyCodeLine{\ \ \ \ \{\ t3(stream)\ \}\ -\/>\ std::same\_as<task<void>>;}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md69}{}\doxysubsection{\texorpdfstring{payload\+\_\+handler}{payload\_handler}}\label{md_include_2webcraft_2web_2README_autotoc_md69}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Ret>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }payload\_handler\ =\ \textcolor{keyword}{requires}(T\ t1,\ T\&\ t2,\ T\&\&\ t3,\ web\_read\_stream\&\ stream)\ \{}
\DoxyCodeLine{\ \ \ \ \{\ t1(stream)\ \}\ -\/>\ std::same\_as<task<Ret>>;}
\DoxyCodeLine{\ \ \ \ \{\ t2(stream)\ \}\ -\/>\ std::same\_as<task<Ret>>;}
\DoxyCodeLine{\ \ \ \ \{\ t3(stream)\ \}\ -\/>\ std::same\_as<task<Ret>>;}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md70}{}\doxysubsection{\texorpdfstring{headers namespace}{headers namespace}}\label{md_include_2webcraft_2web_2README_autotoc_md70}
There will also be a namespace just for the common headers and their values.\hypertarget{md_include_2webcraft_2web_2README_autotoc_md71}{}\doxysubsection{\texorpdfstring{payloads namespace}{payloads namespace}}\label{md_include_2webcraft_2web_2README_autotoc_md71}
There will be a namespace called payloads which has a bunch of functions which help convert to and from C++ friendly objects into {\ttfamily payload\+\_\+dispatcher} and {\ttfamily payload\+\_\+handler}.\hypertarget{md_include_2webcraft_2web_2README_autotoc_md72}{}\doxysection{\texorpdfstring{namespace webcraft\+::web\+::connection}{namespace webcraft::web::connection}}\label{md_include_2webcraft_2web_2README_autotoc_md72}
These are the foundational interfaces required to have connections on both the client and server side to be served on TLS or plain text, on TCP or UDP, and on HTTP/1.\+1, HTTP/2 or HTTP/3.\hypertarget{md_include_2webcraft_2web_2README_autotoc_md73}{}\doxysubsection{\texorpdfstring{connection}{connection}}\label{md_include_2webcraft_2web_2README_autotoc_md73}
The underlying connection for an HTTP connection is defined by the following primitive\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }connection}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{virtual}\ async\_t<size\_t>\ send\_data(message\ data)\ =\ 0;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{virtual}\ async\_t<size\_t>\ recv\_data(message\ data)\ =\ 0;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{virtual}\ connection\_protocol\ get\_protocol()\ =\ 0;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{virtual}\ std::optional<ssl\_context>\ get\_ssl\_context()\ \{\ \textcolor{keywordflow}{return}\ std::nullopt;\ \};}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{virtual}\ std::string\ get\_remote\_host();}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{virtual}\ uint16\_t\ get\_remote\_port();}
\DoxyCodeLine{\};}

\end{DoxyCode}


This underlying connection tells us a couple details about itself\+: what protocol is it running on, information about the peers host and port, and whether its using tls or not. Apart from that, it also allows us to send and receive data to the peer.\hypertarget{md_include_2webcraft_2web_2README_autotoc_md74}{}\doxysubsection{\texorpdfstring{connection\+\_\+provider}{connection\_provider}}\label{md_include_2webcraft_2web_2README_autotoc_md74}
Not all connections are created the same way and not all connections have the same properties but we do need a centralized mechanism to provide us with such connections\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }connection\_provider}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{virtual}\ task<std::shared\_ptr<connection>>\ get\_connection()\ =\ 0;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{virtual}\ std::vector<connection\_protocol>\ get\_supported\_protocols()\ =\ 0;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{virtual}\ \textcolor{keywordtype}{bool}\ tls\_supported()\ =\ 0;\ \textcolor{comment}{//\ will\ return\ false\ until\ tls\ is\ implemented}}
\DoxyCodeLine{\};}

\end{DoxyCode}
 The implementation of this class would take many circumstances into account\+: Are we the server accepting connections or are we the client creating these connections? are we using TLS or plain text? are we using HTTP/1.\+1 or HTTP/2 (both TCP based) or HTTP/3 (UDP based)? The connection provider will give us these details and will allow us to acquire a connection, strategy will be depending on the implementation of this interface.\hypertarget{md_include_2webcraft_2web_2README_autotoc_md75}{}\doxysubsubsection{\texorpdfstring{Usage}{Usage}}\label{md_include_2webcraft_2web_2README_autotoc_md75}
For a {\bfseries{client}} implementing a {\ttfamily connection\+\_\+provider}, this would be a specific provider for a particular host and port (localhost\+:9080, google.\+com, microsoft.\+com, ibm.\+com, etc). Here either new connections are pooled (keep-\/alive), multiplexed (HTTP/2 or HTTP/3), or spawned (new TCP connection) depending on what protocols the server at that address supports. Similarly {\ttfamily get\+\_\+supported\+\_\+protocols} and {\ttfamily tls\+\_\+supported} are based on what the server supports.

For a {\bfseries{server}} implementing a {\ttfamily connection\+\_\+provider}, this provider would represent the provider of the server. {\ttfamily get\+\_\+connection} receives a connection, whether its a multiplexed connection, pooled connection, new connection, or a QUIC connection. {\ttfamily get\+\_\+supported\+\_\+protocols} is based on what the "{}server"{} supports (and is also limited by framework features -\/ can\textquotesingle{}t do HTTP/3 if UDP support is not existant). {\ttfamily tls\+\_\+supported} is based on whether the server using this provider has enabled TLS.\hypertarget{md_include_2webcraft_2web_2README_autotoc_md76}{}\doxysubsection{\texorpdfstring{connection\+\_\+protocol}{connection\_protocol}}\label{md_include_2webcraft_2web_2README_autotoc_md76}
The definition of connection protocol is shown here. It lists out the types of HTTP protocols which will be used. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{enum\ class}\ connection\_protocol}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ HTTP\_1\_0,}
\DoxyCodeLine{\ \ \ \ HTTP\_1\_1,}
\DoxyCodeLine{\ \ \ \ HTTP\_2,}
\DoxyCodeLine{\ \ \ \ HTTP\_3}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md77}{}\doxysection{\texorpdfstring{namespace webcraft\+::web\+::client}{namespace webcraft::web::client}}\label{md_include_2webcraft_2web_2README_autotoc_md77}
The web client API that we provide is inspired by multiple other languages implementation including JS implementations ({\ttfamily fetch}, {\ttfamily axios}, {\ttfamily XMLHTTPRequest}, {\ttfamily Web\+Socket}, {\ttfamily Event\+Object}), Java ({\ttfamily HTTPClient}, {\ttfamily Web\+Client}, {\ttfamily HTTPUrl\+Connection}), and C\# ({\ttfamily Web\+Client}, {\ttfamily HTTPClient}). This API will implement the connection provider to supply connections to the client. As such, there should be ideally one {\ttfamily web\+\_\+client} per application since it will pool and multiplex connections.\hypertarget{md_include_2webcraft_2web_2README_autotoc_md78}{}\doxysubsection{\texorpdfstring{web\+\_\+client}{web\_client}}\label{md_include_2webcraft_2web_2README_autotoc_md78}
The definition is below. Seems pretty lean right? {\ttfamily web\+\_\+client} provides the mechanism to create a connection using {\ttfamily web\+\_\+connection\+\_\+builder} and its possible to attach or create a {\ttfamily web\+\_\+connection\+\_\+builder} via constructor passing in a web\+\_\+client. Just following fluent pattern\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_client}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ set\_ssl\_trust\_store(ssl\_trust\_store\ store);\ \textcolor{comment}{//\ sets\ trust\ store\ -\/\ will\ throw\ tls\_not\_implemented\_error\ until\ tls\ is\ implemented}}
\DoxyCodeLine{\ \ \ \ ssl\_trust\_store\&\ get\_trust\_store()\ \textcolor{comment}{//\ gets\ the\ trust\ store\ -\/\ will\ throw\ tls\_not\_implemented\_error\ until\ tls\ is\ implemented}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ task<\textcolor{keywordtype}{void}>\ close();\ \textcolor{comment}{//\ closes\ any\ outstanding\ connections\ that\ are\ kept\ alive}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ web\_connection\_builder\ connect();}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md79}{}\doxysubsection{\texorpdfstring{web\+\_\+connection\+\_\+builder}{web\_connection\_builder}}\label{md_include_2webcraft_2web_2README_autotoc_md79}
The definition is below.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_connection\_builder}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{class\ }web\_client;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ web\_connection\_builder(web\_client\&\ ref);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ builders}}
\DoxyCodeLine{\ \ \ \ web\_connection\_builder\&\ path(uri\ target\_uri);}
\DoxyCodeLine{\ \ \ \ web\_connection\_builder\&\ method(http\_method\ method);\ \textcolor{comment}{//\ changes\ to\ this\ have\ no\ effect\ on\ websocket\ based\ connections}}
\DoxyCodeLine{\ \ \ \ web\_connection\_builder\&\ headers(std::unordered\_map<std::string,\ std::vector<std::string>>\ headers);}
\DoxyCodeLine{\ \ \ \ web\_connection\_builder\&\ header(std::string\ name,\ std::string\ value);}
\DoxyCodeLine{\ \ \ \ web\_connection\_builder\&\ proxy(uri\ proxy\_uri);}
\DoxyCodeLine{\ \ \ \ web\_connection\_builder\&\ allow\_redirects(\textcolor{keywordtype}{bool}\ allow\ =\ \textcolor{keyword}{true});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ task<web\_client\_connection>\ request\_raw();}
\DoxyCodeLine{\ \ \ \ task<web\_socket\_connection>\ websocket();\ \textcolor{comment}{//\ don't\ fill\ in\ \`{}method`\ since\ websockets\ on\ HTTP/1.1\ and\ HTTP/2\ \&\ 3\ are\ different}}
\DoxyCodeLine{\ \ \ \ task<web\_response>\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_af2b81544adcc4ba129f31b5797a43670}{send}}(payload\_dispatcher\ \textcolor{keyword}{auto}\&\&\ sender);}
\DoxyCodeLine{\};}

\end{DoxyCode}


Through this class, we can build composable builders to spawn templated connections. We can specify the path, the method, the headers, the proxy, redirect handling, and continue building until we are ready to make the connection. We have 3 options at this point.
\begin{DoxyEnumerate}
\item We can directly handle the connection afterwards and get ourselves a {\ttfamily web\+\_\+client\+\_\+connection}.
\item We can create a {\ttfamily web\+\_\+socket\+\_\+connection}.
\item We can send a payload by providing a {\ttfamily payload\+\_\+dispatcher} and receiving a {\ttfamily web\+\_\+response}.
\end{DoxyEnumerate}

Through Option 1, we can handle the read and write streams how we want and gain more control over how the connection is actually going to be handled. This is great if you want to do some ping ponging data processing like what g\+RPC does on HTTP/2 (will be kinda hacky on HTTP/1.\+1 since {\bfseries{technically}} HTTP/1.\+1 does not support ping-\/ponging) or if you feel that the {\ttfamily send} function isn\textquotesingle{}t good enough (which it probably is for non ping-\/pong related exchanges).

Through Option 2, we can create a websocket client at the given addresses. Note that the path is recommended to start with "{}ws\+://"{} and "{}wss\+://"{} and not with "{}http\+://"{} or "{}https\+://"{} (though I\textquotesingle{}ll be forgiving and rewrite that http part to ws). Also note that whatever you set the method to... it doesn\textquotesingle{}t matter, if its HTTP/1.\+1 it will send a GET request with an Upgrade header, if its HTTP/2 it will send a CONNECT request and set some websocket headers. Any headers set by the client which are "{}websocket"{} headers will be overwritten, anything which is not websocket related will be kept.

Through Option 3, we can have {\ttfamily fetch} or {\ttfamily axios} or {\ttfamily HTTPClient} like syntax for sending requests. You can create a function or a class which obeys the payload dispatcher and reference it or you can use some of the existing ones in the {\ttfamily payloads} namespace described in the {\ttfamily webcraft\+::web\+::core} section\hypertarget{md_include_2webcraft_2web_2README_autotoc_md80}{}\doxysubsection{\texorpdfstring{web\+\_\+response\+\_\+base}{web\_response\_base}}\label{md_include_2webcraft_2web_2README_autotoc_md80}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_response\_base}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ std::optional<std::string>\ get\_response\_header(std::string\ name);}
\DoxyCodeLine{\ \ \ \ std::vector<std::string>\ get\_response\_headers(std::string\ name);}
\DoxyCodeLine{\ \ \ \ std::unordered\_map<std::string,\ std::vector<std::string>>\ get\_response\_headers();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ http\_response\_code\ get\_response\_code();}
\DoxyCodeLine{\ \ \ \ http\_method\ get\_method();}
\DoxyCodeLine{\ \ \ \ connection\_protocol\ get\_protocol();}
\DoxyCodeLine{\ \ \ \ std::string\ get\_remote\_host();}
\DoxyCodeLine{\ \ \ \ uint16\_t\ get\_remote\_port();}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md81}{}\doxysubsection{\texorpdfstring{web\+\_\+client\+\_\+connection}{web\_client\_connection}}\label{md_include_2webcraft_2web_2README_autotoc_md81}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_client\_connection\ :\ \textcolor{keyword}{public}\ web\_response\_base}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ web\_read\_stream\ \textcolor{keyword}{auto}\&\ get\_read\_stream();}
\DoxyCodeLine{\ \ \ \ web\_write\_stream\ \textcolor{keyword}{auto}\&\ get\_write\_stream();}
\DoxyCodeLine{\ \ \ \ task<void>\ close();}
\DoxyCodeLine{\};}

\end{DoxyCode}


Represents a raw client connection. Allows the user to manage input and output stream processing directly.\hypertarget{md_include_2webcraft_2web_2README_autotoc_md82}{}\doxysubsection{\texorpdfstring{web\+\_\+socket\+\_\+connection}{web\_socket\_connection}}\label{md_include_2webcraft_2web_2README_autotoc_md82}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_socket\_connection\ :\ \textcolor{keyword}{public}\ web\_response\_base}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ web\_read\_stream\&\ get\_read\_stream();}
\DoxyCodeLine{\ \ \ \ web\_write\_stream\&\ get\_write\_stream();}
\DoxyCodeLine{\ \ \ \ task<void>\ close();}
\DoxyCodeLine{\};}

\end{DoxyCode}


Represents a websocket connection. It looks like its the same as {\ttfamily web\+\_\+client\+\_\+connection} but its actually establishing an HTTP connection under the hood and then running the Web\+Socket protocol on top of it.\hypertarget{md_include_2webcraft_2web_2README_autotoc_md83}{}\doxysubsection{\texorpdfstring{web\+\_\+response}{web\_response}}\label{md_include_2webcraft_2web_2README_autotoc_md83}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_response\ :\ \textcolor{keyword}{public}\ web\_response\_base}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\ \ \ \ task<T>\ get\_payload(payload\_handler<T>\ \textcolor{keyword}{auto}\&\&\ handler);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ task<void>\ close();}
\DoxyCodeLine{\};}

\end{DoxyCode}


Allows us to get the payload. You can create a function or a class which obeys the payload handler and reference it or you can use some of the existing ones in the {\ttfamily payloads} namespace described in the {\ttfamily webcraft\+::web\+::core} section.\hypertarget{md_include_2webcraft_2web_2README_autotoc_md84}{}\doxysection{\texorpdfstring{namespace webcraft\+::web\+::server}{namespace webcraft::web::server}}\label{md_include_2webcraft_2web_2README_autotoc_md84}
Web Clients are fun and necessary but clients are supposed to connect to something and thats what this framework helping you craft, web servers. So lets get into the real deal.\hypertarget{md_include_2webcraft_2web_2README_autotoc_md85}{}\doxysubsection{\texorpdfstring{web\+\_\+server}{web\_server}}\label{md_include_2webcraft_2web_2README_autotoc_md85}
The web server implementation is defined as follows\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_server}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ server\ properties}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ add\_supported\_protocol(connection\_protocol\ protocol);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ set\_ssl\_context(ssl\_context\ ctx);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ set\_property(std::string\ key,\ std::string\ value);}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ server\ runtime\ management\ functions}}
\DoxyCodeLine{\ \ \ \ task<void>\ start();}
\DoxyCodeLine{\ \ \ \ fire\_and\_forget\_task\ \mbox{\hyperlink{namespacewebcraft_1_1async_a32cc887e48f12d360656c6f023977a2d}{shutdown}}();}
\DoxyCodeLine{\ \ \ \ task<void>\ run\_until\_stopped(std::stop\_token\ token);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ lifetime\ hooks}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ on\_started(server\_state\_cb\ \textcolor{keyword}{auto}\&\&\ cb);}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ on\_shutdown(server\_state\_cb\ \textcolor{keyword}{auto}\&\&\ cb);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ routing}}
\DoxyCodeLine{\ \ \ \ web\_route\&\ route(std::vector<std::string>\ routes);}
\DoxyCodeLine{\};}

\end{DoxyCode}


It supports setting initialization proeprties (constants defined in the namespace like "{}http.\+port"{} and "{}https.\+port"{} and "{}host"{}). It also allows asynchronously starting the program (start the server and have it run in the background). Once the server is started we can be notified by setting {\ttfamily on\+\_\+started} callback. We can signal shutdown using the {\ttfamily shutdown} function and once our server is shutdown, we can get a notification on the {\ttfamily on\+\_\+shutdown} callback. Another approach would be to have a stop source and have it run until the stop\+\_\+token is fired (callbacks will still be fired, {\ttfamily shutdown} signal takes more priority than stop token passed in). To perform routing and serving, we can use the {\ttfamily route} function to provide us a representation of what happens in that route.\hypertarget{md_include_2webcraft_2web_2README_autotoc_md86}{}\doxysubsection{\texorpdfstring{server\+\_\+state\+\_\+cb \& web\+\_\+server\+\_\+context\+\_\+manager}{server\_state\_cb \& web\_server\_context\_manager}}\label{md_include_2webcraft_2web_2README_autotoc_md86}
Our callbacks look like this. We are implementing bare minimum CDI since languages like JS \& Python have features where in the middleware they can "{}attach"{} information to the request object. While you can bypass this by setting some special header internally and checking if thats good, this would be better to manage "{}server"{} scoped logic.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }server\_state\_cb\ =\ \textcolor{keyword}{requires}(T\ t1,\ T\&\ t2,\ T\&\&\ t3,\ web\_server\_context\_manager\ manager)\ \{}
\DoxyCodeLine{\ \ \ \ \{\ t1(manager)\ \}\ -\/>\ std::same\_as<task<void>>;}
\DoxyCodeLine{\ \ \ \ \{\ t2(manager)\ \}\ -\/>\ std::same\_as<task<void>>;}
\DoxyCodeLine{\ \ \ \ \{\ t3(manager)\ \}\ -\/>\ std::same\_as<task<void>>;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_server\_context\_manager}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\ \ \ \ T\ get(std::string\ item);}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ set(std::string\ item,\ T\ value);}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md87}{}\doxysubsection{\texorpdfstring{web\+\_\+route \& error\+\_\+handler\+\_\+route \& cors\+\_\+config}{web\_route \& error\_handler\_route \& cors\_config}}\label{md_include_2webcraft_2web_2README_autotoc_md87}
The web route represents the your actual route. Middleware can be handled directly using the {\ttfamily use} function. You can also perform raw request handling (non websocket ping-\/ponging or custom protocol ontop of HTTP like g\+RPC) in the {\ttfamily use} function (I\textquotesingle{}d recommend you to do so here).

The route will be continoud to be "{}chained"{} until the user chooses to have it handle HTTP connections or Web\+Socket connections which it will then fallback on an error\+\_\+handler\+\_\+route. This error handler route can pass in an {\ttfamily error\+\_\+handler\+\_\+cb} in which if some exception happens along the chain, this route is the first responder (and our internal server stuff being the next).

Lastly, all API should be able to be visible on the brwoser side so CORS config has been added.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_route}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ web\_route\&\ use(web\_route\_handler\_cb\ handler);\ \textcolor{comment}{//\ for\ middleware\ or\ raw\ connections}}
\DoxyCodeLine{\ \ \ \ web\_route\&\ cors(cors\_config\ config);\ \textcolor{comment}{//\ CORS\ handler}}
\DoxyCodeLine{\ \ \ \ error\_handler\_route\ handle\_http\_method(http\_method\ method,\ http\_route\_handler\_cb\ handler);\ \textcolor{comment}{//\ for\ basic\ http\ connections}}
\DoxyCodeLine{\ \ \ \ error\_handler\_route\ handle\_websocket(web\_socket\_handler\_cb\ handler);\ \textcolor{comment}{//\ for\ websocket\ connections}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class\ }error\_handler\_route}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ on\_error(error\_handler\ \textcolor{keyword}{auto}\&\&\ handler);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{struct\ }cors\_config}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ std::vector<http\_method>\ allowed\_methods;}
\DoxyCodeLine{\ \ \ \ std::vector<std::string>\ allowed\_origins;}
\DoxyCodeLine{\ \ \ \ std::vector<std::string>\ allowed\_headers;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ allow\_credentials;}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md88}{}\doxysubsection{\texorpdfstring{web\+\_\+route\+\_\+handler \& http\+\_\+route\+\_\+handler \& web\+\_\+socket\+\_\+handler \& error\+\_\+handler\+\_\+cb}{web\_route\_handler \& http\_route\_handler \& web\_socket\_handler \& error\_handler\_cb}}\label{md_include_2webcraft_2web_2README_autotoc_md88}
Our callbacks. I find its kind of self explainatory. {\ttfamily web\+\_\+route\+\_\+handler}, {\ttfamily web\+\_\+socket\+\_\+handler}, {\ttfamily error\+\_\+handler\+\_\+cb} both accept a connection scoped context, a request which provides a readable stream, and a response which provides a writable stream. {\ttfamily web\+\_\+route\+\_\+handler} returns a boolean where true indicates the connection is successfully handled and we can stop and false indicates that the connection needs to be handled by the downstream handlers. {\ttfamily http\+\_\+route\+\_\+handler} is different, it accepts a request which provides a payload and returns a response object. {\ttfamily error\+\_\+handler\+\_\+cb} provides an exception pointer object.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }web\_route\_handler\_cb\ =\ \textcolor{keyword}{requires}(T\ t1,\ T\&\ t2,\ T\&\&\ t3,\ web\_server\_context\_view\ view,\ web\_request\ req,\ web\_response\ resp)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \{\ t1(view,\ req,\ resp,\ func)\ \}\ -\/>\ std::same\_as<task<bool>>;}
\DoxyCodeLine{\ \ \ \ \{\ t2(view,\ req,\ resp,\ func)\ \}\ -\/>\ std::same\_as<task<bool>>;}
\DoxyCodeLine{\ \ \ \ \{\ t3(view,\ req,\ resp,\ func)\ \}\ -\/>\ std::same\_as<task<bool>>;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }http\_route\_handler\_cb\ =\ \textcolor{keyword}{requires}(T\ t1,\ T\&\ t2,\ T\&\&\ t3,\ web\_server\_context\_view\ view,\ http\_request\ req)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \{\ t1(view,\ req,\ resp)\ \}\ -\/>\ std::same\_as<task<http\_response>>;}
\DoxyCodeLine{\ \ \ \ \{\ t2(view,\ req,\ resp)\ \}\ -\/>\ std::same\_as<task<http\_response>>;}
\DoxyCodeLine{\ \ \ \ \{\ t3(view,\ req,\ resp)\ \}\ -\/>\ std::same\_as<task<http\_response>>;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }web\_socket\_handler\_cb\ =\ \textcolor{keyword}{requires}(T\ t1,\ T\&\ t2,\ T\&\&\ t3,\ web\_server\_context\_view\ view,\ web\_socket\_request\ req,\ web\_socket\_response\ resp)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \{\ t1(view,\ req,\ resp)\ \}\ -\/>\ std::same\_as<task<void>>;}
\DoxyCodeLine{\ \ \ \ \{\ t2(view,\ req,\ resp)\ \}\ -\/>\ std::same\_as<task<void>>;}
\DoxyCodeLine{\ \ \ \ \{\ t3(view,\ req,\ resp)\ \}\ -\/>\ std::same\_as<task<void>>;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }error\_handler\_cb\ =\ \textcolor{keyword}{requires}(T\ t1,\ T\&\ t2,\ T\&\&\ t3,\ std::exception\_ptr\ ptr,\ web\_server\_context\_view\ view,\ web\_request\ req,\ web\_response\ resp)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \{\ t1(ptr,\ view,\ req,\ resp)\ \}\ -\/>\ std::same\_as<task<void>>;}
\DoxyCodeLine{\ \ \ \ \{\ t2(ptr,\ view,\ req,\ resp)\ \}\ -\/>\ std::same\_as<task<void>>;}
\DoxyCodeLine{\ \ \ \ \{\ t3(ptr,\ view,\ req,\ resp)\ \}\ -\/>\ std::same\_as<task<void>>;}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md89}{}\doxysubsection{\texorpdfstring{web\+\_\+server\+\_\+context\+\_\+view}{web\_server\_context\_view}}\label{md_include_2webcraft_2web_2README_autotoc_md89}
This is how connection scoped CDI looks like.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_server\_context\_view}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\ \ \ \ T\ get\_global(std::string\ item);}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ set\_global(std::string\ item,\ T\ value);}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\ \ \ \ T\ get\_local(std::string\ item);}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ set\_local(std::string\ item,\ T\ value);}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md90}{}\doxysubsection{\texorpdfstring{Web Requests}{Web Requests}}\label{md_include_2webcraft_2web_2README_autotoc_md90}
This is the definition for the base of all web requests.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_request\_base}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ std::unordered\_map<std::string,\ std::string>\ get\_path\_params();}
\DoxyCodeLine{\ \ \ \ std::optional<std::string>\ get\_path\_param(std::string\ param);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ std::unordered\_map<std::string,\ std::string>\ get\_query\_params();}
\DoxyCodeLine{\ \ \ \ std::optional<std::string>\ get\_query\_param(std::string\ param);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ std::string\ get\_path();}
\DoxyCodeLine{\ \ \ \ std::string\ get\_http\_method();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ std::unordered\_map<std::string,\ std::vector<std::string>>\ get\_headers();}
\DoxyCodeLine{\ \ \ \ std::vector<std::string>\ get\_headers(std::string\ name);}
\DoxyCodeLine{\ \ \ \ std::optional<std::string>\ get\_headers(std::string\ name);}
\DoxyCodeLine{\};}

\end{DoxyCode}


These are the individual request types.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_request\ :\ \textcolor{keyword}{public}\ web\_request\_base}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ web\_read\_stream\ \textcolor{keyword}{auto}\&\ get\_read\_stream();}
\DoxyCodeLine{}
\DoxyCodeLine{\};}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_socket\_request\ :\ \textcolor{keyword}{public}\ web\_request\_base}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ web\_read\_stream\ \textcolor{keyword}{auto}\&\ get\_read\_stream();}
\DoxyCodeLine{\};}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }http\_request\ :\ \textcolor{keyword}{public}\ web\_request\_base}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\ \ \ \ task<T>\ get\_payload(payload\_handler<T>\ \textcolor{keyword}{auto}\&\&\ handler);}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md91}{}\doxysubsection{\texorpdfstring{Web Responses}{Web Responses}}\label{md_include_2webcraft_2web_2README_autotoc_md91}
This is the definition for the base of all web responses.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_response\_base}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ task<void>\ set\_status\_code(http\_code\ code);}
\DoxyCodeLine{\ \ \ \ task<void>\ set\_header(std::string\ name,\ std::string\ value);}
\DoxyCodeLine{\};}

\end{DoxyCode}


These are the individual response types.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_response\ :\ \textcolor{keyword}{public}\ web\_response\_base}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ web\_write\_stream\ \textcolor{keyword}{auto}\&\ get\_write\_stream();}
\DoxyCodeLine{\};}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }web\_socket\_response\ :\ \textcolor{keyword}{public}\ web\_response\_base}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ web\_write\_stream\ \textcolor{keyword}{auto}\&\ get\_write\_stream();}
\DoxyCodeLine{\};}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class\ }http\_response}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{class\ }web\_server;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ http\_response\&\ set\_response\_code(http\_code\ code);}
\DoxyCodeLine{\ \ \ \ http\_response\&\ set\_header(std::string\ name,\ std::string\ header);}
\DoxyCodeLine{\ \ \ \ http\_response\&\ set\_headers(std::unordered\_map<std::string,\ std::vector<std::string>>\ headers);}
\DoxyCodeLine{\ \ \ \ http\_response\&\ set\_payload(payload\_dispatcher\ \textcolor{keyword}{auto}\&\&\ dispatcher);}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2web_2README_autotoc_md92}{}\doxysection{\texorpdfstring{namespace webcraft\+::web\+::secure}{namespace webcraft::web::secure}}\label{md_include_2webcraft_2web_2README_autotoc_md92}
Coming Soon.... will need to add Open\+SSL into the mix.\hypertarget{md_include_2webcraft_2web_2README_autotoc_md93}{}\doxysection{\texorpdfstring{Resources}{Resources}}\label{md_include_2webcraft_2web_2README_autotoc_md93}

\begin{DoxyItemize}
\item \href{https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Resources_and_specifications}{\texttt{ https\+://developer.\+mozilla.\+org/en-\/\+US/docs/\+Web/\+HTTP/\+Reference/\+Resources\+\_\+and\+\_\+specifications}}
\item \href{https://httpwg.org/specs/}{\texttt{ https\+://httpwg.\+org/specs/}}
\item \href{https://websocket.org/guides/websocket-protocol/}{\texttt{ https\+://websocket.\+org/guides/websocket-\/protocol/}}
\item \href{https://websockets.spec.whatwg.org/}{\texttt{ https\+://websockets.\+spec.\+whatwg.\+org/}}
\item \href{https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers}{\texttt{ https\+://developer.\+mozilla.\+org/en-\/\+US/docs/\+Web/\+API/\+Web\+Sockets\+\_\+\+API/\+Writing\+\_\+\+Web\+Socket\+\_\+servers}}
\item \href{https://www.rfc-editor.org/rfc/rfc7118.html}{\texttt{ https\+://www.\+rfc-\/editor.\+org/rfc/rfc7118.\+html}} 
\end{DoxyItemize}