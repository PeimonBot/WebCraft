\chapter{Asynchronous I/O in Web\+Craft}
\hypertarget{md_include_2webcraft_2async_2io_2README}{}\label{md_include_2webcraft_2async_2io_2README}\index{Asynchronous I/O in WebCraft@{Asynchronous I/O in WebCraft}}
\label{md_include_2webcraft_2async_2io_2README_autotoc_md0}%
\Hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md0}%
 This readme covers how Web\+Craft handles {\bfseries{Asynchronous I/O}} powered with C++ coroutines.

Table of Contents\+:


\begin{DoxyEnumerate}
\item Async Streams
\item Async Readable Stream Adaptors
\item Async File I/O
\item Async Socket I/O
\end{DoxyEnumerate}\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md1}{}\doxysection{\texorpdfstring{Async Streams}{Async Streams}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md1}
Async I/O in webcraft is implemented using the concept of Streams (similar to Java Streams API and Input/\+Output Streams). There are 2 types of async streams defined in the {\ttfamily \doxylink{namespacewebcraft_1_1async_1_1io}{webcraft\+::async\+::io}} namespace\+: async readable streams and async writable streams.\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md2}{}\doxysubsection{\texorpdfstring{Async readable streams}{Async readable streams}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md2}
The definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Derived,\ \textcolor{keyword}{typename}\ R>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }async\_readable\_stream\ =\ std::is\_move\_constructible\_v<Derived>\ \&\&\ \textcolor{keyword}{requires}(Derived\ \&stream)\ \{}
\DoxyCodeLine{\ \ \ \ \{\ stream.recv()\ \}\ -\/>\ std::same\_as<webcraft::async::task<std::optional<R>>>;}
\DoxyCodeLine{\};}

\end{DoxyCode}


Any type which models {\ttfamily async\+\_\+readable\+\_\+stream\texorpdfstring{$<$}{<}Derived, R\texorpdfstring{$>$}{>}} must have a function {\ttfamily recv()} which takes no arguments and returns a {\ttfamily \doxylink{classwebcraft_1_1async_1_1task}{webcraft\+::async\+::task}\texorpdfstring{$<$}{<}std\+::optional\texorpdfstring{$<$}{<}R\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}}. Here {\ttfamily R} represents the type of value streamed to the client. The end of the stream is denoted when the result of the task is {\ttfamily std\+::nullopt}; subsequent calls to {\ttfamily recv()} will also result in {\ttfamily std\+::nullopt}.

There is also a buffered variant for streams which implement buffering internally\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Derived,\ \textcolor{keyword}{typename}\ R>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }async\_buffered\_readable\_stream\ =\ async\_readable\_stream<Derived,\ R>\ \&\&\ \textcolor{keyword}{requires}(Derived\ \&stream,\ std::span<R>\ buffer)\ \{}
\DoxyCodeLine{\ \ \ \ \{\ stream.recv(buffer)\ \}\ -\/>\ std::same\_as<webcraft::async::task<std::size\_t>>;}
\DoxyCodeLine{\};}

\end{DoxyCode}


The buffered variant allows you to receive multiple objects at once from the stream. Internally, the regular {\ttfamily recv()} variant will either call the buffered variant with a buffer size of 1 or buffer values internally, so if values already exist in the internal queue, it only needs to pop them instead of waiting.\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md3}{}\doxysubsection{\texorpdfstring{Async writable streams}{Async writable streams}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md3}
The definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Derived,\ \textcolor{keyword}{typename}\ R>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }async\_writable\_stream\ =\ std::is\_move\_constructible\_v<Derived>\ \&\&\ \textcolor{keyword}{requires}(Derived\ \&stream,\ R\ value)\ \{}
\DoxyCodeLine{\ \ \ \ \{\ stream.send(value)\ \}\ -\/>\ std::same\_as<webcraft::async::task<bool>>;}
\DoxyCodeLine{\};}

\end{DoxyCode}


Any type which models {\ttfamily async\+\_\+writable\+\_\+stream\texorpdfstring{$<$}{<}Derived, R\texorpdfstring{$>$}{>}} must have a function {\ttfamily send(\+R)} which takes an rvalue reference for R (to be moved into the stream) and returns a {\ttfamily \doxylink{classwebcraft_1_1async_1_1task}{webcraft\+::async\+::task}\texorpdfstring{$<$}{<}bool\texorpdfstring{$>$}{>}} indicating whether the value was successfully written.

There is also a buffered variant which allows you to write multiple objects at once (better for batching)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Derived,\ \textcolor{keyword}{typename}\ R>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }async\_buffered\_writable\_stream\ =\ async\_writable\_stream<Derived,\ R>\ \&\&\ \textcolor{keyword}{requires}(Derived\ \&stream,\ std::span<R>\ buffer)\ \{}
\DoxyCodeLine{\ \ \ \ \{\ stream.send(buffer)\ \}\ -\/>\ std::same\_as<webcraft::async::task<size\_t>>;}
\DoxyCodeLine{\};}

\end{DoxyCode}


This version accepts a span of values which will be written to the stream and returns the number of values actually written.\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md4}{}\doxysubsection{\texorpdfstring{Async stream helpers}{Async stream helpers}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md4}
For those who want to read and write multiple values without knowing whether the implementation provides buffering, we provide helper functions in the {\ttfamily \doxylink{namespacewebcraft_1_1async_1_1io}{webcraft\+::async\+::io}} namespace\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ R,\ async\_readable\_stream<R>\ RStream,\ \textcolor{keywordtype}{size\_t}\ BufferSize>}
\DoxyCodeLine{\mbox{\hyperlink{classwebcraft_1_1async_1_1task}{webcraft::async::task<std::size\_t>}}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_aaaf5c2dda44d2ea9c9518aa85bf729c1}{recv}}(RStream\ \&stream,\ std::span<R,\ BufferSize>\ buffer);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ R,\ async\_writable\_stream<R>\ WStream,\ \textcolor{keywordtype}{size\_t}\ BufferSize>}
\DoxyCodeLine{\mbox{\hyperlink{classwebcraft_1_1async_1_1task}{webcraft::async::task<size\_t>}}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_af2b81544adcc4ba129f31b5797a43670}{send}}(WStream\ \&stream,\ std::span<R,\ BufferSize>\ buffer);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ R,\ async\_readable\_stream<R>\ RStream>}
\DoxyCodeLine{\mbox{\hyperlink{classcppcoro_1_1async__generator}{cppcoro::async\_generator<R>}}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_a7e1420555f9b1c5e37aecdf9086d972d}{to\_async\_generator}}(RStream\ \&\&stream);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ R>}
\DoxyCodeLine{async\_readable\_stream<R>\ \textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_a65fdb2f3bc3e4af76fe30526dcb1e4b1}{to\_readable\_stream}}(\mbox{\hyperlink{classcppcoro_1_1async__generator}{cppcoro::async\_generator<R>}}\ \&\&gen);}

\end{DoxyCode}


The batched {\ttfamily recv()} and {\ttfamily send()} functions call the buffered stream variants if a buffered stream is passed, otherwise they call the non-\/buffered variants repeatedly until the span is filled or until no more data can be read/written.

The conversion to and from async generators are provided for readable streams since it enables powerful functional-\/style stream processing\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ fn\ =\ [](\textcolor{keywordtype}{size\_t}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a7f89d23f44cca5e13f844ad7c5b3282d}{limit}})\ -\/>\ async\_generator<int>\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{size\_t}\ count\ =\ 0;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{while}\ (count\ <\ limit)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_await}\ sleep(200ms);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_yield}\ count++;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ rstream\ =\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_a65fdb2f3bc3e4af76fe30526dcb1e4b1}{webcraft::async::io::to\_readable\_stream}}(fn(10));}
\DoxyCodeLine{\textcolor{keywordflow}{while}\ (\textcolor{keyword}{auto}\ opt\ =\ \textcolor{keyword}{co\_await}\ rstream.recv())\ \{}
\DoxyCodeLine{\ \ \ \ handle(opt.value());}
\DoxyCodeLine{\}}

\end{DoxyCode}


This will allow us to add a powerful set of adaptors onto async streams similar to the adaptors added with the ranges library onto iterables. From this, we can build powerful stream processing and pub/sub systems which can do a variety of processing without requiring manual stream processing.

{\bfseries{Note\+:}} All examples in this document use the {\ttfamily \doxylink{namespacewebcraft_1_1async_1_1io}{webcraft\+::async\+::io}} namespace. For brevity, some code examples may omit the full namespace qualification, but all types and functions are within this namespace.\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md5}{}\doxysubsection{\texorpdfstring{Channels}{Channels}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md5}
Channels are a mechanism to transfer data from a publisher to a subscriber. The model implemented is MPSC (Multiple Producer, Single Consumer) since it only makes sense to deal with one event at a time. You can create an MPSC channel as shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ [rstream,\ wstream]\ =\ webcraft::async::io::make\_mpsc\_channel<int>();}

\end{DoxyCode}


The type of {\ttfamily rstream} satisfies {\ttfamily async\+\_\+readable\+\_\+stream} and the type of {\ttfamily wstream} satisfies {\ttfamily async\+\_\+writable\+\_\+stream}. This effectively creates an asynchronous pipe. Concurrency is handled automatically -\/ whenever {\ttfamily send()} is called on the writable stream, any waiting read operations are resumed.

{\bfseries{NOTE\+: DO NOT pipe {\ttfamily rstream} into {\ttfamily wstream} as it will cause an infinite loop since all values received from read will be sent to write, which will trigger another read, creating a stack overflow.}}

Working with channels becomes useful for building highly scalable Publisher-\/\+Subscriber applications. Most microservices use message queues which internally use channels since they make working with event streams much easier. Channels are used internally for managing async socket I/O and async file I/O.\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md6}{}\doxysection{\texorpdfstring{Async Readable Stream Adaptors}{Async Readable Stream Adaptors}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md6}
Streams aren\textquotesingle{}t really useful by themselves. Most of the time, we want to transform raw data into something useful. This is the idea of a {\bfseries{stream adaptor}}. We take a readable stream of one data type, apply some operation (mapping, filtering, transforming), and get a stream of another data type.

Here\textquotesingle{}s an example\+:

Suppose we want to group students into a map by letter grade (A for 80-\/100, B for 70-\/80, C for 60-\/70, D for 50-\/60), filter out failing students, and sort students within each group\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }student\ \{}
\DoxyCodeLine{\ \ \ \ std::string\ name;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{double}\ average;}
\DoxyCodeLine{\};}

\end{DoxyCode}


The adaptor-\/based solution using Web\+Craft\textquotesingle{}s stream adaptors\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::string\ average\_to\_grade(\textcolor{keywordtype}{double}\ average)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}\ (average\ >=\ 80.0)\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}A"{}};}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}\ (average\ >=\ 70.0)\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}B"{}};}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}\ (average\ >=\ 60.0)\ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}C"{}};}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{stringliteral}{"{}D"{}};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{classwebcraft_1_1async_1_1task}{webcraft::async::task<std::unordered\_map<std::string,\ std::vector<student>}}>>\ }
\DoxyCodeLine{get\_student\_grade\_groupings(\mbox{\hyperlink{conceptwebcraft_1_1async_1_1io_1_1async__readable__stream}{webcraft::async::io::async\_readable\_stream<student>}}\ \textcolor{keyword}{auto}\ students)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{using\ namespace\ }\mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors}{webcraft::async::io::adaptors}};}
\DoxyCodeLine{\ \ \ \ }
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{co\_return}\ \textcolor{keyword}{co\_await}\ (std::move(students)\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_adda76c1251d855604fa6c9f4b752de2c}{filter}}([](\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ st)\ \{\ \textcolor{keywordflow}{return}\ st.average\ >=\ 50.0;\ \})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_ac259db7916278ffc530b8c127be7a191}{collect}}(collectors::group\_by([](\textcolor{keyword}{const}\ student\&\ st)\ \{\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ average\_to\_grade(st.average);\ }
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \})));}
\DoxyCodeLine{\}}

\end{DoxyCode}


This greatly reduces the amount of code and logic required. There are many other uses for async streams, especially when dealing with pub/sub systems.\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md7}{}\doxysubsection{\texorpdfstring{Stream Adaptors Implementation}{Stream Adaptors Implementation}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md7}
All stream adaptors inherit from {\ttfamily async\+\_\+readable\+\_\+stream\+\_\+adaptor}. The definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Derived,\ \textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{struct\ }\mbox{\hyperlink{structwebcraft_1_1async_1_1io_1_1adaptors_1_1async__readable__stream__adaptor}{async\_readable\_stream\_adaptor}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{auto}\ operator|(async\_readable\_stream<T>\ \textcolor{keyword}{auto}\ \&\&stream,\ Derived\ \&adaptor)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::invoke(adaptor,\ std::move(stream));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{friend}\ \textcolor{keyword}{auto}\ operator|(async\_readable\_stream<T>\ \textcolor{keyword}{auto}\ \&\&stream,\ Derived\ \&\&adaptor)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::invoke(std::move(adaptor),\ std::forward<\textcolor{keyword}{decltype}(stream)>(stream));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\};}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md8}{}\doxysubsubsection{\texorpdfstring{Transform adaptor}{Transform adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md8}
Definition\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InType,\ \textcolor{keyword}{typename}\ Func>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_ab1e6d4ed87247b8982c2536eeb7220e5}{transform}}(Func\ \&\&fn)\ -\/>\ \textcolor{comment}{/*\ adaptor\ type\ */};}

\end{DoxyCode}


Transform an existing async\+\_\+readable\+\_\+stream to another async\+\_\+readable\+\_\+stream. The function must have signature {\ttfamily \doxylink{classcppcoro_1_1async__generator}{cppcoro\+::async\+\_\+generator}\texorpdfstring{$<$}{<}Out\+Type\texorpdfstring{$>$}{>}(\doxylink{classcppcoro_1_1async__generator}{cppcoro\+::async\+\_\+generator}\texorpdfstring{$<$}{<}In\+Type\texorpdfstring{$>$}{>})}. Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ new\_stream\ =\ stream\ |\ webcraft::async::io::adaptors::transform<int>([](\mbox{\hyperlink{classcppcoro_1_1async__generator}{cppcoro::async\_generator<int>}}\ gen)\ -\/>\ \mbox{\hyperlink{classcppcoro_1_1async__generator}{cppcoro::async\_generator<std::string>}}\ \{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{async__generator_8hpp_a4d7b3885bfafff1b24249b43416127d2}{for\_each\_async}}(value,\ gen,\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_yield}\ std::to\_string(value);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_yield}\ std::to\_string(value\ *\ 2);\ \textcolor{comment}{//\ Duplicate\ and\ double}}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{\});}
\DoxyCodeLine{\textcolor{comment}{//\ Result:\ ["{}1"{},\ "{}2"{},\ "{}2"{},\ "{}4"{},\ "{}3"{},\ "{}6"{},\ "{}4"{},\ "{}8"{},\ "{}5"{},\ "{}10"{}]}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md9}{}\doxysubsubsection{\texorpdfstring{Map adaptor}{Map adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md9}
Definition\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ InType,\ \textcolor{keyword}{typename}\ Func,\ \textcolor{keyword}{typename}\ OutType\ =\ std::invoke\_result\_t<Func,\ InType>>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a467323c557b8245b25c7cc5c6cd28e22}{map}}(Func\ \&\&fn)\ -\/>\ \textcolor{comment}{/*\ adaptor\ type\ */};}

\end{DoxyCode}


Create a new readable stream with values mapped using the provided function. Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ new\_stream\ =\ stream\ |\ webcraft::async::io::adaptors::map<int>([](\textcolor{keywordtype}{int}\ value)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ std::to\_string(value);}
\DoxyCodeLine{\});}
\DoxyCodeLine{\textcolor{comment}{//\ Result:\ ["{}1"{},\ "{}2"{},\ "{}3"{},\ "{}4"{},\ "{}5"{}]}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md10}{}\doxysubsubsection{\texorpdfstring{Pipe adaptor}{Pipe adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md10}
Definition\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{requires}\ std::is\_copy\_assignable\_v<T>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_ade46e7a4ed2b78a5081564b197a8ea57}{pipe}}(\mbox{\hyperlink{conceptwebcraft_1_1async_1_1io_1_1async__writable__stream}{webcraft::async::io::async\_writable\_stream<T>}}\ \textcolor{keyword}{auto}\ \&str)\ -\/>\ \textcolor{comment}{/*\ adaptor\ type\ */};}

\end{DoxyCode}


Create a new readable stream that forwards read values to the provided writable stream. Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ rstream(\{1,2,3,4,5\});}
\DoxyCodeLine{mock\_writable\_stream<int>\ wstream;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ new\_stream\ =\ rstream\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_ade46e7a4ed2b78a5081564b197a8ea57}{webcraft::async::io::adaptors::pipe}}(wstream);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{while}\ (\textcolor{keyword}{auto}\ opt\ =\ \textcolor{keyword}{co\_await}\ new\_stream.recv())\ \{}
\DoxyCodeLine{\ \ \ \ assert(wstream.received\_value(*opt));}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md11}{}\doxysubsubsection{\texorpdfstring{Filter adaptor}{Filter adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md11}
Definition\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Func>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_adda76c1251d855604fa6c9f4b752de2c}{filter}}(Func\ \&\&predicate)\ -\/>\ \textcolor{comment}{/*\ adaptor\ type\ */};}

\end{DoxyCode}


Filter values in the stream based on a predicate. Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{\textcolor{keyword}{auto}\ new\_stream\ =\ stream\ |\ webcraft::async::io::adaptors::filter<int>([](\textcolor{keywordtype}{int}\ value)\ \{\ }
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ value\ \%\ 2\ ==\ 0;\ }
\DoxyCodeLine{\});}
\DoxyCodeLine{\textcolor{comment}{//\ Result:\ [2,4]}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md12}{}\doxysubsubsection{\texorpdfstring{Limit adaptor}{Limit adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md12}
Definition\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a7f89d23f44cca5e13f844ad7c5b3282d}{limit}}(\textcolor{keywordtype}{size\_t}\ size)\ -\/>\ \textcolor{comment}{/*\ adaptor\ type\ */};}

\end{DoxyCode}


Limit the number of values sent through the stream. Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{\textcolor{keyword}{auto}\ new\_stream\ =\ stream\ |\ webcraft::async::io::adaptors::limit<int>(3);}
\DoxyCodeLine{\textcolor{comment}{//\ Result:\ [1,2,3]}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md13}{}\doxysubsubsection{\texorpdfstring{Skip adaptor}{Skip adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md13}
Definition\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a5102607d13477fb88df1a0b93c50e6d1}{skip}}(\textcolor{keywordtype}{size\_t}\ size)\ -\/>\ \textcolor{comment}{/*\ adaptor\ type\ */};}

\end{DoxyCode}


Skip a number of values at the beginning of the stream. Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{\textcolor{keyword}{auto}\ new\_stream\ =\ stream\ |\ webcraft::async::io::adaptors::skip<int>(2);}
\DoxyCodeLine{\textcolor{comment}{//\ Result:\ [3,4,5]}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md14}{}\doxysubsubsection{\texorpdfstring{Take while adaptor}{Take while adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md14}
Definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Func>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a16136cc18f9808fabc53ff6ab854d997}{take\_while}}(Func\&\&\ func)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor, you\textquotesingle{}d be able to take the values sent through the stream while the predicate defined by {\ttfamily Func} yields true. {\ttfamily Func} must have the following type signature {\ttfamily bool(const T\&)}. An example is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{async\_readable\_stream<int>\ \textcolor{keyword}{auto}\ new\_stream\ =\ stream\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a16136cc18f9808fabc53ff6ab854d997}{take\_while}}([](\textcolor{keywordtype}{int}\ i)\ \{\ \textcolor{keywordflow}{return}\ i\ <\ 2;\ \});}
\DoxyCodeLine{\textcolor{comment}{//\ streams\ returned\ is\ [1,2]}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md15}{}\doxysubsubsection{\texorpdfstring{Drop while adaptor}{Drop while adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md15}
Definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Func>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_ad7cac35a119147fb1d053553ff1ce6f4}{drop\_while}}(Func\&\&\ func)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor, you\textquotesingle{}d be able to drop the values sent through the stream while the predicate defined by {\ttfamily Func} yields true. {\ttfamily Func} must have the following type signature {\ttfamily bool(const T\&)}. An example is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{async\_readable\_stream<int>\ \textcolor{keyword}{auto}\ new\_stream\ =\ stream\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_ad7cac35a119147fb1d053553ff1ce6f4}{drop\_while}}([](\textcolor{keywordtype}{int}\ i)\ \{\ \textcolor{keywordflow}{return}\ i\ <\ 2;\ \});}
\DoxyCodeLine{\textcolor{comment}{//\ streams\ returned\ is\ [3,4,5]}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md16}{}\doxysubsubsection{\texorpdfstring{Collect adaptor}{Collect adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md16}
Definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Derived,\ \textcolor{keyword}{typename}\ ToType,\ \textcolor{keyword}{typename}\ StreamType>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }collector\ =\ std::is\_invocable\_r\_v<task<ToType>,\ Derived,\ \mbox{\hyperlink{classcppcoro_1_1async__generator}{async\_generator<StreamType>}}>;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ ToType,\ \textcolor{keyword}{typename}\ StreamType,\ collector<ToType,\ StreamType>\ Collector>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_ac259db7916278ffc530b8c127be7a191}{collect}}(Collector\ \&\&collector\_func)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor, you\textquotesingle{}ll be able to convert the readable stream into something more tangible like another object or a {\ttfamily std\+::vector} of an object. This would be really useful especially for processing of REST requests when they give you a stream of bytes, you\textquotesingle{}ll be able to collect it into a JSON object.

There are many ways to create your own collector, you can create your own, for example to convert a stream of bytes into a JSON object, or you can use some of the in-\/built ones\+:


\begin{DoxyItemize}
\item reduce
\item joining
\item to\+\_\+vector
\item group\+\_\+by
\end{DoxyItemize}\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md17}{}\doxyparagraph{\texorpdfstring{Reduce collector}{Reduce collector}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md17}
Defined as shown\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_1_1collectors_a7daa10abd28848093f764efd3678bc98}{reduce}}(std::function<T(T,\ T)>\ \&\&func);}

\end{DoxyCode}


When collected, this will return a {\ttfamily task\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} which can be awaited to give you the result. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ values\ =\ \textcolor{keyword}{co\_await}\ (stream\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_ac259db7916278ffc530b8c127be7a191}{collect}}(collectors::reduce([](\textcolor{keywordtype}{int}\ first,\ \textcolor{keywordtype}{int}\ second)\ \{\ \textcolor{keywordflow}{return}\ first\ +\ second;\ \})));}
\DoxyCodeLine{assert(values\ ==\ 15);}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md18}{}\doxyparagraph{\texorpdfstring{Joining collector}{Joining collector}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md18}
Defined as shown\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{requires}\ std::is\_convertible\_v<T,\ std::string>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_1_1collectors_adc8e437445f9247f3e767b485f468b5d}{joining}}(std::string\ separator\ =\ \textcolor{stringliteral}{"{}"{}},\ std::string\ prefix\ =\ \textcolor{stringliteral}{"{}"{}},\ std::string\ suffix\ =\ \textcolor{stringliteral}{"{}"{}})}

\end{DoxyCode}


When collected, this will return a {\ttfamily task\texorpdfstring{$<$}{<}std\+::string\texorpdfstring{$>$}{>}} which can be awaited to give you the result. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream(\{\textcolor{stringliteral}{"{}1"{}},\textcolor{stringliteral}{"{}2"{}},\textcolor{stringliteral}{"{}3"{}},\textcolor{stringliteral}{"{}4"{}},\textcolor{stringliteral}{"{}5"{}}\});}
\DoxyCodeLine{std::string\ values\ =\ \textcolor{keyword}{co\_await}\ (stream\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_ac259db7916278ffc530b8c127be7a191}{collect}}(collectors::joinin(\textcolor{stringliteral}{"{},"{}})));}
\DoxyCodeLine{assert(values\ ==\ \textcolor{stringliteral}{"{}1,2,3,4,5"{}});}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md19}{}\doxyparagraph{\texorpdfstring{To Vector collector}{To Vector collector}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md19}
Defined as shown\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_1_1collectors_a1064184038eb4e5d67a1763dbc2c33f9}{to\_vector}}();}

\end{DoxyCode}


When collected, this will return a {\ttfamily task\texorpdfstring{$<$}{<}std\+::vector\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}} which can be awaited to give you the result. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{std::vector<int>\ values\ =\ \textcolor{keyword}{co\_await}\ (stream\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_ac259db7916278ffc530b8c127be7a191}{collect}}(collectors::to\_vector()));}
\DoxyCodeLine{\textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ values.size();\ i++)\ \{}
\DoxyCodeLine{\ \ \ \ assert(values[i]\ ==\ i\ +\ 1);}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md20}{}\doxyparagraph{\texorpdfstring{Group By collector}{Group By collector}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md20}
Defined as shown\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ KeyType>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_1_1collectors_a2e67493f2e10fee623eb18b43d02ea71}{group\_by}}(std::function<KeyType(\textcolor{keyword}{const}\ T\ \&)>\ key\_function);}

\end{DoxyCode}


When collected, this will return a {\ttfamily task\texorpdfstring{$<$}{<}std\+::unordered\+\_\+map\texorpdfstring{$<$}{<}Key\+Type, std\+::vector\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}} which can be awaited to give you the result. Example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<std::string>\ stream(\{\textcolor{stringliteral}{"{}AB"{}},\ \textcolor{stringliteral}{"{}BC"{}},\ \textcolor{stringliteral}{"{}AC"{}},\ \textcolor{stringliteral}{"{}BD"{}},\ \textcolor{stringliteral}{"{}CD"{}}\});}
\DoxyCodeLine{\textcolor{keyword}{auto}\ mapper\ =\ [](std::string\ value)\ -\/>\ std::string\ \{\ \textcolor{comment}{//\ groups\ it\ by\ the\ first\ letter}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ std::string(value[0]);\ \textcolor{comment}{//\ A*\ -\/>\ A,\ B*\ -\/>\ B}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{std::unordered\_map<std::string,\ std::vector<std::string>>\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a467323c557b8245b25c7cc5c6cd28e22}{map}}\ =\ \textcolor{keyword}{co\_await}\ (stream\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_ac259db7916278ffc530b8c127be7a191}{collect}}(collectors::group\_by(mapper)));}
\DoxyCodeLine{\textcolor{comment}{//\ \ returns\ a\ \{\ \{"{}A"{},\ ["{}AB"{},"{}AC"{}]\},\ \{"{}B"{},\ ["{}BC"{},"{}BD"{}]\},\ \{"{}C"{},\ ["{}CD"{}]\}\ \}}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md21}{}\doxysubsubsection{\texorpdfstring{Forward To adaptor}{Forward To adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md21}
Definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a9ddb8e7a2a4c065a9340e9800ff7f0ed}{forward\_to}}(async\_writable\_stream<T>\ \textcolor{keyword}{auto}\ \&stream)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor, you\textquotesingle{}ll be able to forward all objects coming from the readable stream into the output stream passed. When applied, the adaptor will return a {\ttfamily task\texorpdfstring{$<$}{<}void\texorpdfstring{$>$}{>}} which you can await for all the values to be sent into the stream. An example of this is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ rstream(\{1,2,3,4,5\});}
\DoxyCodeLine{mock\_writable\_stream<int>\ wstream;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{co\_await}\ (rstream\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a9ddb8e7a2a4c065a9340e9800ff7f0ed}{forward\_to}}(wstream));}
\DoxyCodeLine{\textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 1;\ i\ <=\ 5;\ i++)\ \{}
\DoxyCodeLine{\ \ \ \ assert(wstream.received(i));}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md22}{}\doxysubsubsection{\texorpdfstring{Min adaptor}{Min adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md22}
Definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{requires}\ std::totally\_ordered<T>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_abe983922626e1ab45c906444bbf74239}{min}}()\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor, you\textquotesingle{}d be able to find the minimum value sent through the stream. An example is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ min\_value\ =\ \textcolor{keyword}{co\_await}\ (stream\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_abe983922626e1ab45c906444bbf74239}{min}}());}
\DoxyCodeLine{assert(min\_value\ ==\ 1);}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md23}{}\doxysubsubsection{\texorpdfstring{Max adaptor}{Max adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md23}
Definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{requires}\ std::totally\_ordered<T>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a5d9d3a60fa12ea699dc5fc59ae5d0f63}{max}}()\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor, you\textquotesingle{}d be able to find the maximum value sent through the stream. An example is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ max\_value\ =\ \textcolor{keyword}{co\_await}\ (stream\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a5d9d3a60fa12ea699dc5fc59ae5d0f63}{max}}());}
\DoxyCodeLine{assert(max\_value\ ==\ 5);}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md24}{}\doxysubsubsection{\texorpdfstring{Sum adaptor}{Sum adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md24}
Definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{concept\ }closure\_under\_addition\ =\ \textcolor{keyword}{requires}(T\ a,\ T\ b)\ \{}
\DoxyCodeLine{\ \ \ \ \{\ a\ +\ b\ \}\ -\/>\ std::convertible\_to<T>;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{requires}\ closure\_under\_addition<T>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a01eae8f829e97817419aed01f5ad37dc}{sum}}()\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor, you\textquotesingle{}d be able to find the sum of the values sent through the stream. An example is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a01eae8f829e97817419aed01f5ad37dc}{sum}}\ =\ \textcolor{keyword}{co\_await}\ (stream\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a01eae8f829e97817419aed01f5ad37dc}{sum}}());}
\DoxyCodeLine{assert(sum\ ==\ 15);}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md25}{}\doxysubsubsection{\texorpdfstring{Find first adaptor}{Find first adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md25}
Definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Func>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_afea35e0603fe1056bdc052faa20b8411}{find\_first}}(Func\&\&\ func)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor, you\textquotesingle{}d be able to find the first value sent through the stream which matches the following predicate. An example is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ value\ =\ \textcolor{keyword}{co\_await}\ (stream\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_afea35e0603fe1056bdc052faa20b8411}{find\_first}}([](\textcolor{keywordtype}{int}\ value)\ \{\ \textcolor{keywordflow}{return}\ value\ \%\ 2\ ==\ 0;\ \}));}
\DoxyCodeLine{assert(value\ ==\ 2);}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md26}{}\doxysubsubsection{\texorpdfstring{Find last adaptor}{Find last adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md26}
Definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Func>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a21b0723e172b9758a9e78ae20dbe3bf1}{find\_last}}(Func\&\&\ func)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor, you\textquotesingle{}d be able to find the last value sent through the stream which matches the following predicate. An example is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream(\{1,2,3,4,5\});}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ value\ =\ \textcolor{keyword}{co\_await}\ (stream\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a21b0723e172b9758a9e78ae20dbe3bf1}{find\_last}}([](\textcolor{keywordtype}{int}\ value)\ \{\ \textcolor{keywordflow}{return}\ value\ \%\ 2\ ==\ 0;\ \}));}
\DoxyCodeLine{assert(value\ ==\ 4);}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md27}{}\doxysubsubsection{\texorpdfstring{Any matches adaptor}{Any matches adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md27}
Definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Func>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_af103d36599b9cd7baf15f2c7e75e70b9}{any\_matches}}(Func\&\&\ func)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor, you\textquotesingle{}d be able to check if there are any values which match the predicate. An example is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream\_1(\{2,4,3,5\});}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream\_2(\{1,3,5\});}
\DoxyCodeLine{\textcolor{keywordtype}{bool}\ check1\ =\ \textcolor{keyword}{co\_await}\ (stream\_1\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_af103d36599b9cd7baf15f2c7e75e70b9}{any\_matches}}([](\textcolor{keywordtype}{int}\ value)\ \{\ \textcolor{keywordflow}{return}\ value\ \%\ 2\ ==\ 0;\ \}));}
\DoxyCodeLine{assert(check1);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{bool}\ check2\ =\ \textcolor{keyword}{co\_await}\ (stream\_2\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_af103d36599b9cd7baf15f2c7e75e70b9}{any\_matches}}([](\textcolor{keywordtype}{int}\ value)\ \{\ \textcolor{keywordflow}{return}\ value\ \%\ 2\ ==\ 0;\ \}));}
\DoxyCodeLine{assert(!check2);}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md28}{}\doxysubsubsection{\texorpdfstring{All matches adaptor}{All matches adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md28}
Definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Func>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a1566ca935350435b72631ee11d574ee7}{all\_matches}}(Func\&\&\ func)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor, you\textquotesingle{}d be able to check if all values which match the predicate. An example is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream\_1(\{2,4,6,8\});}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream\_2(\{2,4,6,7\});}
\DoxyCodeLine{\textcolor{keywordtype}{bool}\ check1\ =\ \textcolor{keyword}{co\_await}\ (stream\_1\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a1566ca935350435b72631ee11d574ee7}{all\_matches}}([](\textcolor{keywordtype}{int}\ value)\ \{\ \textcolor{keywordflow}{return}\ value\ \%\ 2\ ==\ 0;\ \}));}
\DoxyCodeLine{assert(check1);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{bool}\ check2\ =\ \textcolor{keyword}{co\_await}\ (stream\_2\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_a1566ca935350435b72631ee11d574ee7}{all\_matches}}([](\textcolor{keywordtype}{int}\ value)\ \{\ \textcolor{keywordflow}{return}\ value\ \%\ 2\ ==\ 0;\ \}));}
\DoxyCodeLine{assert(!check2);}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md29}{}\doxysubsubsection{\texorpdfstring{None matches adaptor}{None matches adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md29}
Definition is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ Func>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_af103d36599b9cd7baf15f2c7e75e70b9}{any\_matches}}(Func\&\&\ func)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor, you\textquotesingle{}d be able to check if all values do not match the predicate. An example is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream\_1(\{2,4,3,5\});}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream\_2(\{1,3,5\});}
\DoxyCodeLine{\textcolor{keywordtype}{bool}\ check1\ =\ \textcolor{keyword}{co\_await}\ (stream\_1\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_af0226fefe32175663e7ab469a785566c}{none\_matches}}([](\textcolor{keywordtype}{int}\ value)\ \{\ \textcolor{keywordflow}{return}\ value\ \%\ 2\ ==\ 0;\ \}));}
\DoxyCodeLine{assert(!check1);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{bool}\ check2\ =\ \textcolor{keyword}{co\_await}\ (stream\_2\ |\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1adaptors_af0226fefe32175663e7ab469a785566c}{none\_matches}}([](\textcolor{keywordtype}{int}\ value)\ \{\ \textcolor{keywordflow}{return}\ value\ \%\ 2\ ==\ 0;\ \}));}
\DoxyCodeLine{assert(check2);}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md30}{}\doxysubsection{\texorpdfstring{Some of the adaptors are planned to be implemented in this framework\+:}{Some of the adaptors are planned to be implemented in this framework:}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md30}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md31}{}\doxysubsubsection{\texorpdfstring{Sorted adaptor}{Sorted adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md31}
Definition is as shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{\textcolor{keyword}{requires}\ std::totally\_ordered<T>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ sorted()\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ R>}
\DoxyCodeLine{\textcolor{keyword}{requires}\ std::totally\_ordered<R>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ sorted(std::function<R(T)>\ comparator)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor on a readable stream will create a new sorted readable stream from the old stream (all values will be sorted in the order specified). An example of the usage is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ values\_1(\{5,1,3,6,4,2\});}
\DoxyCodeLine{async\_readable\_stream<int>\ \textcolor{keyword}{auto}\ new\_stream\_1\ =\ values\_1\ |\ sorted();\ \textcolor{comment}{//\ 1,2,3,4,5,6}}
\DoxyCodeLine{\textcolor{comment}{//\ the\ new\ steam\ satisfies\ async\_readable\_stream<1>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ another\ example}}
\DoxyCodeLine{mock\_readable\_stream<std::pair<int,\ std::string>>\ values\_2(\{\{5,\textcolor{stringliteral}{"{}5"{}}\},\ \{1,\textcolor{stringliteral}{"{}1"{}}\},\ \{\textcolor{stringliteral}{"{}3"{}},3\},\ \{6,\textcolor{stringliteral}{"{}6"{}}\},\ \{4,\textcolor{stringliteral}{"{}4"{}}\},\{2,\textcolor{stringliteral}{"{}2"{}}\}\});}
\DoxyCodeLine{async\_readable\_stream<std::pair<int,\ std::string>>\ \textcolor{keyword}{auto}\ new\_stream\_2\ =\ values\_2\ |\ sorted([](\textcolor{keyword}{auto}\ value)\ \{\ \textcolor{keywordflow}{return}\ value.key;\ \});\ \textcolor{comment}{//\ \{1,"{}1"{}\},\{2,"{}2"{}\},\{3,"{}3"{}\},\{4,"{}4"{}\},\{5,"{}5"{}\},\{6,"{}6"{}\}}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md32}{}\doxysubsubsection{\texorpdfstring{Zip adaptor}{Zip adaptor}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md32}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ R>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ zip\_inner(async\_readable\_stream<R>\ str)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ R>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ zip\_left(async\_readable\_stream<R>\ str)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ R>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ zip\_right(async\_readable\_stream<R>\ str)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ R>}
\DoxyCodeLine{\textcolor{keyword}{auto}\ zip\_full(async\_readable\_stream<R>\ str)\ -\/>\ std::is\_derived\_from<async\_readable\_stream\_adaptor>;}

\end{DoxyCode}


Using this adaptor you\textquotesingle{}ll be able to group 2 streams together into one. An example of this is shown below\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mock\_readable\_stream<int>\ stream1(\{1,2,3,4,5\});}
\DoxyCodeLine{mock\_readable\_stream<std::string>\ stream2(\{\textcolor{stringliteral}{"{}1"{}},\textcolor{stringliteral}{"{}2"{}},\textcolor{stringliteral}{"{}3"{}},\textcolor{stringliteral}{"{}4"{}},\textcolor{stringliteral}{"{}5"{}}\});}
\DoxyCodeLine{}
\DoxyCodeLine{async\_readable\_stream<std::pair<std::optional<int>,\ std::optional<std::string>>>\ \textcolor{keyword}{auto}\ new\_stream\ =\ stream1\ |\ zip\_full(stream2);\ \textcolor{comment}{//\ \{1,"{}1"{}\},\{2,"{}2"{}\},\{3,"{}3"{}\},\{4,"{}4"{}\},\{5,"{}5"{}\},\{6,"{}6"{}\}}}
\DoxyCodeLine{\textcolor{comment}{//\ the\ new\ steam\ satisfies\ async\_readable\_stream<std::pair<std::optional<int>,\ std::optional<std::string>>>}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md33}{}\doxysection{\texorpdfstring{Async File I/O}{Async File I/O}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md33}
Async File I/O is handled differently on different platforms using the {\ttfamily \doxylink{namespacewebcraft_1_1async_1_1io_1_1fs}{webcraft\+::async\+::io\+::fs}} namespace. The framework provides a unified interface while leveraging platform-\/specific optimizations\+:\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md34}{}\doxysubsection{\texorpdfstring{File Operations Table}{File Operations Table}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md34}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{7}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Library   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Platforms Supported   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Special Create?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Read?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Write?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Close?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Notes    }\\\cline{1-7}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Library   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Platforms Supported   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Special Create?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Read?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Write?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Close?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Notes    }\\\cline{1-7}
\endhead
IO Completion Ports   &Windows Only ({\ttfamily \texorpdfstring{$<$}{<}windows.\+h\texorpdfstring{$>$}{>}})   &Synchronous but sets up async IO\+:\href{https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea}{\texttt{ {\ttfamily Create\+File\+Ex}}} + \href{https://learn.microsoft.com/en-us/windows/win32/fileio/createiocompletionport}{\texttt{ {\ttfamily Create\+IOCompletion\+Port}}}   &\href{https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile}{\texttt{ {\ttfamily Read\+File}}}   &\href{https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile}{\texttt{ {\ttfamily Write\+File}}}   &No Async Version. Just \href{https://learn.microsoft.com/en-us/windows/win32/api/handleapi/nf-handleapi-closehandle}{\texttt{ {\ttfamily Close\+Handle}}}   &{\bfseries{Summary\+:}} Synchronous create and close and async read and write but only for windows.    \\\cline{1-7}
io\+\_\+uring   &Linux Only ({\ttfamily \texorpdfstring{$<$}{<}liburing.\+h\texorpdfstring{$>$}{>}})   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_open.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+open}}}   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_read.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+read}}}   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_write.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+write}}}   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_close.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+close}}}   &{\bfseries{Summary\+:}} Has async support for all file functions but only for linux    \\\cline{1-7}
kqueue + aio   &Pure BSD-\/based systems like Free\+BSD ({\ttfamily \texorpdfstring{$<$}{<}sys/event.\+h\texorpdfstring{$>$}{>}} + {\ttfamily \texorpdfstring{$<$}{<}aio.\+h\texorpdfstring{$>$}{>}})   &Synchronous\+: Use POSIX{\ttfamily open}   &Use{\ttfamily aio\+\_\+read} with kqueue   &Use{\ttfamily aio\+\_\+write} with   &Synchronous\+: Use {\ttfamily close}   &{\bfseries{NOTE\+: Make sure when the kqueue result has returned to call {\ttfamily aio\+\_\+return}.}}    \\\cline{1-7}
Thread pool   &Mac\+OS or any other system which does not support Async File I/O natively   &Synchronous\+: Use POSIX{\ttfamily open}   &Use{\ttfamily read} on thread pool   &Use{\ttfamily write} on thread   &Synchronous\+: Use{\ttfamily close}   &Use a thread pool    \\\cline{1-7}
GCD   &Mac\+OS Only -\/ plan on implementing this in the next PR   &tbd   &tdb   &tdb   &tdb   &Need to look into this more   \\\cline{1-7}
\end{longtabu}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md35}{}\doxysection{\texorpdfstring{Async Socket I/O}{Async Socket I/O}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md35}
Async Socket I/O is handled differently on different platforms using the {\ttfamily \doxylink{namespacewebcraft_1_1async_1_1io_1_1socket}{webcraft\+::async\+::io\+::socket}} namespace.\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md36}{}\doxysubsection{\texorpdfstring{TCP Sockets Table}{TCP Sockets Table}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md36}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{9}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Library   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Platforms Supported   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Special Create?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Connect?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Read?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Write?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Close?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Shutdown?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Notes    }\\\cline{1-9}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Library   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Platforms Supported   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Special Create?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Connect?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Read?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Write?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Close?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Shutdown?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Notes    }\\\cline{1-9}
\endhead
io\+\_\+uring   &Linux   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_socket.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+socket}}}   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_connect.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+connect}}}   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_read.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+read}}}   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_write.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+write}}}   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_close.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+close}}}   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_shutdown.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+shutdown}}}   &{\bfseries{NOTE\+: All the functions are async just linux only.}}    \\\cline{1-9}
IOCP   &Windows   &\href{https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket}{\texttt{ {\ttfamily socket}}} + \href{https://learn.microsoft.com/en-us/windows/win32/fileio/createiocompletionport}{\texttt{ {\ttfamily Create\+IOCompletion\+Port}}}   &\href{https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_connectex}{\texttt{ {\ttfamily Connect\+Ex}}}   &\href{https://learn.microsoft.com/en-gb/windows/win32/api/winsock2/nf-winsock2-wsarecv}{\texttt{ {\ttfamily WSARecv}}}   &\href{https://learn.microsoft.com/en-gb/windows/win32/api/winsock2/nf-winsock2-wsasend}{\texttt{ {\ttfamily WSASend}}}   &\href{https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-closesocket}{\texttt{ {\ttfamily closesocket}}}   &\href{https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-shutdown}{\texttt{ {\ttfamily shutdown}}}   &{\bfseries{NOTE\+: A call to {\ttfamily bind()} must be made before calling Connect\+Ex otherwise socket will be invalid.}}    \\\cline{1-9}
kqueue   &BSD based systems   &{\ttfamily socket}   &{\ttfamily connect}   &{\ttfamily read}   &{\ttfamily write}   &{\ttfamily close}   &{\ttfamily shutdown}   &{\bfseries{NOTE\+: It seems like it\textquotesingle{}s all just synchronous API calls but kqueue lets us know when to call what under the hood. Kqueue will be our notification agent and we\textquotesingle{}ll use channels and other forms of asynchronous delivery to let us know when to resume. Refer to the kqueue example below.}}   \\\cline{1-9}
\end{longtabu}


Some docs\+:
\begin{DoxyItemize}
\item \href{https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_connectex}{\texttt{ https\+://learn.\+microsoft.\+com/en-\/us/windows/win32/api/mswsock/nc-\/mswsock-\/lpfn\+\_\+connectex}}
\item \href{https://gist.github.com/joeyadams/4158972}{\texttt{ https\+://gist.\+github.\+com/joeyadams/4158972}}
\item \href{https://stackoverflow.com/questions/13598530/connectex-requires-the-socket-to-be-initially-bound-but-to-what}{\texttt{ https\+://stackoverflow.\+com/questions/13598530/connectex-\/requires-\/the-\/socket-\/to-\/be-\/initially-\/bound-\/but-\/to-\/what}}
\end{DoxyItemize}\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md37}{}\doxysubsection{\texorpdfstring{TCP Listeners Table}{TCP Listeners Table}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md37}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{8}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Library   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Platforms Supported   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Special Create?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Bind?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Listen?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Accept   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Close?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Notes    }\\\cline{1-8}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Library   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Platforms Supported   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Special Create?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Bind?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Listen?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Accept   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Async Close?   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Notes    }\\\cline{1-8}
\endhead
io\+\_\+uring   &Linux   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_socket.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+socket}}}   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_bind.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+bind}}}   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_listen.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+listen}}}   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_accept.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+accept}}}   &\href{https://man7.org/linux/man-pages/man3/io_uring_prep_close.3.html}{\texttt{ {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+close}}}   &{\bfseries{NOTE\+: All the functions are async just linux only.}}    \\\cline{1-8}
IOCP   &Windows   &\href{https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-socket}{\texttt{ {\ttfamily socket}}} + \href{https://learn.microsoft.com/en-us/windows/win32/fileio/createiocompletionport}{\texttt{ {\ttfamily Create\+IOCompletion\+Port}}}   &\href{https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-bind}{\texttt{ {\ttfamily bind}}}   &\href{https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen}{\texttt{ {\ttfamily listen}}}   &\href{https://learn.microsoft.com/en-gb/windows/win32/api/mswsock/nf-mswsock-acceptex}{\texttt{ {\ttfamily Accept\+Ex}}}   &\href{https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-closesocket}{\texttt{ {\ttfamily closesocket}}}   &\\\cline{1-8}
kqueue   &BSD based systems   &{\ttfamily socket}   &{\ttfamily bind}   &{\ttfamily listen}   &{\ttfamily accept}   &{\ttfamily close}   &{\bfseries{NOTE\+: It seems like it\textquotesingle{}s all just synchronous API calls but kqueue lets us know when to call what under the hood. Kqueue will be our notification agent and we\textquotesingle{}ll use channels and other forms of asynchronous delivery to let us know when to resume. Refer to the kqueue example below.}}   \\\cline{1-8}
\end{longtabu}


Examples\+:
\begin{DoxyItemize}
\item \href{https://learn.microsoft.com/en-gb/windows/win32/api/mswsock/nf-mswsock-acceptex\#example-code}{\texttt{ https\+://learn.\+microsoft.\+com/en-\/gb/windows/win32/api/mswsock/nf-\/mswsock-\/acceptex\#example-\/code}}
\item \href{https://gist.github.com/josephg/6c078a241b0e9e538ac04ef28be6e787}{\texttt{ https\+://gist.\+github.\+com/josephg/6c078a241b0e9e538ac04ef28be6e787}}
\item KQUEUE Example\+: \href{https://dev.to/frevib/a-tcp-server-with-kqueue-527}{\texttt{ https\+://dev.\+to/frevib/a-\/tcp-\/server-\/with-\/kqueue-\/527}}
\end{DoxyItemize}\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md38}{}\doxysection{\texorpdfstring{Planned implementation\+:}{Planned implementation:}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md38}
Async Read \& Async Write will be based on what\textquotesingle{}s in the {\bfseries{Async Read}} and {\bfseries{Async Write}} columns. Closing will still happen with RAII (which would be a synchronous close on everything but linux) but on linux we\textquotesingle{}ll send a fire-\/and-\/forget request with {\ttfamily io\+\_\+uring\+\_\+prep\+\_\+close}. For async creation it can either be with synchronous or asynchronous, the bottleneck wouldn\textquotesingle{}t be too big of an issue.

This is the following specification for using the {\bfseries{Async File I/O}} API\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{namespace\ }detail}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{class\ }file\_descriptor}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::ios\_base::openmode\ mode;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ file\_descriptor(std::ios\_base::openmode\ mode)\ :\ mode(mode)\ \{\}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \string~file\_descriptor()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{comment}{//\ virtual\ because\ we\ want\ to\ allow\ platform\ specific\ implementation}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<size\_t>}}\ read(std::span<char>\ buffer)\ =\ 0;\ \ \textcolor{comment}{//\ internally\ should\ check\ if\ openmode\ is\ for\ read}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<size\_t>}}\ write(std::span<char>\ buffer)\ =\ 0;\ \textcolor{comment}{//\ internally\ should\ check\ if\ openmode\ is\ for\ write\ or\ append}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<void>}}\ close()\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ will\ spawn\ a\ fire\ and\ forget\ task\ (essentially\ use\ async\ apis\ but\ provide\ null\ callback)}}
\DoxyCodeLine{\ \ \ \ \};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<std::shared\_ptr<file\_descriptor>}}>\ make\_file\_descriptor(std::filesystem::path\ p,\ std::ios\_base::openmode\ mode);}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{class\ }file\_stream}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{protected}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::shared\_ptr<file\_descriptor>\ fd;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::atomic<bool>\ closed\{\textcolor{keyword}{false}\};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{explicit}\ file\_stream(std::shared\_ptr<file\_descriptor>\ fd)\ :\ fd(std::move(fd))\ \{\}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \string~file\_stream()\ noexcept}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (fd)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacewebcraft_1_1async_a367712ca561ac34d7d28f495a6462c09}{sync\_wait}}(close());}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<void>}}\ close()\ noexcept}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{bool}\ expected\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (closed.compare\_exchange\_strong(expected,\ \textcolor{keyword}{true},\ std::memory\_order\_acq\_rel))}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{co\_await}\ fd-\/>close();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class\ }file\_rstream\ :\ \textcolor{keyword}{public}\ detail::file\_stream}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ file\_rstream(std::shared\_ptr<detail::file\_descriptor>\ fd)\ :\ detail::file\_stream(std::move(fd))\ \{\}}
\DoxyCodeLine{\ \ \ \ \string~file\_rstream()\ noexcept\ =\ default;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ file\_rstream(file\_rstream\ \&\&)\ noexcept\ =\ default;}
\DoxyCodeLine{\ \ \ \ file\_rstream\ \&operator=(file\_rstream\ \&\&)\ noexcept\ =\ default;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task}}<\textcolor{keywordtype}{size\_t}>\ recv(std::span<\textcolor{keywordtype}{char}>\ buffer)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ fd-\/>read(buffer);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<char>}}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_aaaf5c2dda44d2ea9c9518aa85bf729c1}{recv}}()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::array<char,\ 1>\ buf;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_await}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_aaaf5c2dda44d2ea9c9518aa85bf729c1}{recv}}(buf);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_return}\ buf[0];}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(async\_readable\_stream<file\_rstream,\ char>);}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(async\_buffered\_readable\_stream<file\_rstream,\ char>);}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(async\_closeable\_stream<file\_rstream,\ char>);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class\ }file\_wstream\ :\ \textcolor{keyword}{public}\ detail::file\_stream}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{explicit}\ file\_wstream(std::shared\_ptr<file\_descriptor>\ fd)\ :\ detail::file\_stream(std::move(fd))\ \{\}}
\DoxyCodeLine{\ \ \ \ \string~file\_wstream()\ noexcept\ =\ default;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ file\_wstream(file\_wstream\ \&\&)\ noexcept\ =\ default;}
\DoxyCodeLine{\ \ \ \ file\_wstream\ \&operator=(file\_wstream\ \&\&)\ noexcept\ =\ default;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task}}<\textcolor{keywordtype}{size\_t}>\ send(std::span<\textcolor{keywordtype}{char}>\ buffer)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ fd-\/>write(buffer);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<bool>}}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_af2b81544adcc4ba129f31b5797a43670}{send}}(\textcolor{keywordtype}{char}\ b)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::array<char,\ 1>\ buf;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ buf[0]\ =\ b;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_await}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_af2b81544adcc4ba129f31b5797a43670}{send}}(buf);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(async\_writable\_stream<file\_wstream,\ char>);}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(async\_buffered\_writable\_stream<file\_wstream,\ char>);}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(async\_closeable\_stream<file\_wstream,\ char>);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class\ }file}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\ \ \ \ std::filesystem::path\ p;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ file(std::filesystem::path\ p)\ :\ p(std::move(p))\ \{\}}
\DoxyCodeLine{\ \ \ \ \string~file()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<file\_rstream>}}\ open\_readable\_stream()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ descriptor\ =\ \textcolor{keyword}{co\_await}\ detail::make\_file\_descriptor(p,\ std::ios\_base::in);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_return}\ file\_rstream(descriptor);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<file\_wstream>}}\ open\_writable\_stream(\textcolor{keywordtype}{bool}\ append)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ descriptor\ =\ \textcolor{keyword}{co\_await}\ detail::make\_file\_descriptor(p,\ append\ ?\ std::ios\_base::app\ :\ std::ios\_base::out);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_return}\ file\_wstream(std::move(descriptor));}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{const}\ std::filesystem::path\ get\_path()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ p;\ \}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{constexpr}\ \textcolor{keyword}{operator}\ \textcolor{keyword}{const}\ std::filesystem::path\ \&()\ \textcolor{keyword}{const}\ \{\ \textcolor{keywordflow}{return}\ p;\ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{file\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1fs_a8d8e45ed576cda72f736cd9e66952947}{make\_file}}(std::filesystem::path\ p)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ file(p);}
\DoxyCodeLine{\}}

\end{DoxyCode}


This is the following specification for using the {\bfseries{Async TCP Socket and Listener I/O}} API\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }connection\_info}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ std::string\ host;}
\DoxyCodeLine{\ \ \ \ uint16\_t\ port;}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{enum\ class}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1socket_a9f2887d3f56db5de0b9d3a9bc63b8688}{socket\_stream\_mode}}}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1socket_a9f2887d3f56db5de0b9d3a9bc63b8688a3466fab4975481651940ed328aa990e4}{READ}},}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1socket_a9f2887d3f56db5de0b9d3a9bc63b8688ad4b9e47f65b6e79b010582f15785867e}{WRITE}}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{namespace\ }detail}
\DoxyCodeLine{\{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{class\ }tcp\_descriptor\_base}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ tcp\_descriptor\_base()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \string~tcp\_descriptor\_base()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<void>}}\ close()\ =\ 0;\ \textcolor{comment}{//\ Close\ the\ socket}}
\DoxyCodeLine{\ \ \ \ \};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{class\ }tcp\_socket\_descriptor\ :\ \textcolor{keyword}{public}\ tcp\_descriptor\_base}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ tcp\_socket\_descriptor()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \string~tcp\_socket\_descriptor()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<void>}}\ connect(\textcolor{keyword}{const}\ connection\_info\ \&info)\ =\ 0;\ \ \textcolor{comment}{//\ Connect\ to\ a\ server}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<size\_t>}}\ read(std::span<char>\ buffer)\ =\ 0;\ \ \ \ \ \ \ \ \textcolor{comment}{//\ Read\ data\ from\ the\ socket}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<size\_t>}}\ write(std::span<const\ char>\ buffer)\ =\ 0;\ \textcolor{comment}{//\ Write\ data\ to\ the\ socket}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{namespacewebcraft_1_1async_a32cc887e48f12d360656c6f023977a2d}{shutdown}}(socket\_stream\_mode\ mode)\ =\ 0;\ \ \ \ \ \textcolor{comment}{//\ Shutdown\ the\ socket}}
\DoxyCodeLine{\ \ \ \ \};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{class\ }tcp\_listener\_descriptor\ :\ \textcolor{keyword}{public}\ tcp\_descriptor\_base}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ \ \ \ \ tcp\_listener\_descriptor()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \string~tcp\_listener\_descriptor()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \textcolor{keywordtype}{void}\ bind(\textcolor{keyword}{const}\ connection\_info\ \&info)\ =\ 0;\ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Bind\ the\ listener\ to\ an\ address}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \textcolor{keywordtype}{void}\ listen(\textcolor{keywordtype}{int}\ backlog)\ =\ 0;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Start\ listening\ for\ incoming\ connections}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{virtual}\ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<std::unique\_ptr<tcp\_socket\_descriptor>}}>\ accept()\ =\ 0;\ \textcolor{comment}{//\ Accept\ a\ new\ connection}}
\DoxyCodeLine{\ \ \ \ \};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ std::shared\_ptr<tcp\_socket\_descriptor>\ make\_tcp\_socket\_descriptor();}
\DoxyCodeLine{\ \ \ \ std::shared\_ptr<tcp\_listener\_descriptor>\ make\_tcp\_listener\_descriptor();}
\DoxyCodeLine{}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class\ }tcp\_rstream}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\ \ \ \ std::shared\_ptr<detail::tcp\_socket\_descriptor>\ descriptor;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ tcp\_rstream(std::shared\_ptr<detail::tcp\_socket\_descriptor>\ desc)\ :\ descriptor(std::move(desc))\ \{\}}
\DoxyCodeLine{\ \ \ \ \string~tcp\_rstream()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<size\_t>}}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_aaaf5c2dda44d2ea9c9518aa85bf729c1}{recv}}(std::span<char>\ buffer)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ descriptor-\/>read(buffer);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<char>}}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_aaaf5c2dda44d2ea9c9518aa85bf729c1}{recv}}()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::array<char,\ 1>\ buf;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_await}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_aaaf5c2dda44d2ea9c9518aa85bf729c1}{recv}}(buf);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_return}\ buf[0];}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<void>}}\ close()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ descriptor-\/>shutdown(socket\_stream\_mode::READ);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_return};}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(async\_writable\_stream<tcp\_rstream,\ char>);}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(async\_buffered\_writable\_stream<tcp\_rstream,\ char>);}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(async\_closeable\_stream<tcp\_rstream,\ char>);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class\ }tcp\_wstream}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\ \ \ \ std::shared\_ptr<detail::tcp\_socket\_descriptor>\ descriptor;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ tcp\_wstream(std::shared\_ptr<detail::tcp\_socket\_descriptor>\ desc)\ :\ descriptor(std::move(desc))\ \{\}}
\DoxyCodeLine{\ \ \ \ \string~tcp\_wstream()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<size\_t>}}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_af2b81544adcc4ba129f31b5797a43670}{send}}(std::span<const\ char>\ buffer)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ descriptor-\/>write(buffer);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<bool>}}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_af2b81544adcc4ba129f31b5797a43670}{send}}(\textcolor{keywordtype}{char}\ b)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::array<char,\ 1>\ buf;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ buf[0]\ =\ b;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_await}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_af2b81544adcc4ba129f31b5797a43670}{send}}(buf);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<void>}}\ close()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ descriptor-\/>shutdown(socket\_stream\_mode::WRITE);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_return};}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(async\_writable\_stream<tcp\_wstream,\ char>);}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(async\_buffered\_writable\_stream<tcp\_wstream,\ char>);}
\DoxyCodeLine{\textcolor{keyword}{static\_assert}(async\_closeable\_stream<tcp\_wstream,\ char>);}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class\ }tcp\_socket}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\ \ \ \ std::shared\_ptr<detail::tcp\_socket\_descriptor>\ descriptor;}
\DoxyCodeLine{\ \ \ \ tcp\_rstream\ read\_stream;}
\DoxyCodeLine{\ \ \ \ tcp\_wstream\ write\_stream;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ read\_shutdown\{\textcolor{keyword}{false}\};}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ write\_shutdown\{\textcolor{keyword}{false}\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ tcp\_socket(std::shared\_ptr<detail::tcp\_socket\_descriptor>\ desc)\ :\ descriptor(desc),\ read\_stream(descriptor),\ write\_stream(descriptor)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \string~tcp\_socket()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacewebcraft_1_1async_aa32214c386ded164491af1d325b36e11}{fire\_and\_forget}}(close());}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ tcp\_socket(tcp\_socket\ \&\&other)\ noexcept}
\DoxyCodeLine{\ \ \ \ \ \ \ \ :\ descriptor(std::exchange(other.descriptor,\ \textcolor{keyword}{nullptr})),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ read\_stream(std::move(other.read\_stream)),}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ write\_stream(std::move(other.write\_stream))}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ tcp\_socket\ \&operator=(tcp\_socket\ \&\&other)\ \textcolor{keyword}{noexcept}}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (\textcolor{keyword}{this}\ !=\ \&other)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ descriptor\ =\ std::exchange(other.descriptor,\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ read\_stream\ =\ std::move(other.read\_stream);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ write\_stream\ =\ std::move(other.write\_stream);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<void>}}\ connect(\textcolor{keyword}{const}\ connection\_info\ \&info)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!descriptor)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ std::runtime\_error(\textcolor{stringliteral}{"{}Descriptor\ is\ null"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_await}\ descriptor-\/>connect(info);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ tcp\_rstream\ \&get\_readable\_stream()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!descriptor)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ std::runtime\_error(\textcolor{stringliteral}{"{}Descriptor\ is\ null"{}});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ read\_stream;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ tcp\_wstream\ \&get\_writable\_stream()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!descriptor)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ std::runtime\_error(\textcolor{stringliteral}{"{}Descriptor\ is\ null"{}});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ write\_stream;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ shutdown\_channel(socket\_stream\_mode\ mode)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (mode\ ==\ socket\_stream\_mode::READ\ \&\&\ !read\_shutdown)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ descriptor-\/>shutdown(socket\_stream\_mode::READ);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ this-\/>read\_shutdown\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}\ \textcolor{keywordflow}{if}\ (mode\ ==\ socket\_stream\_mode::WRITE\ \&\&\ !write\_shutdown)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ descriptor-\/>shutdown(socket\_stream\_mode::WRITE);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ this-\/>write\_shutdown\ =\ \textcolor{keyword}{true};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<void>}}\ close()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (descriptor)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ shutdown\_channel(socket\_stream\_mode::READ);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ shutdown\_channel(socket\_stream\_mode::WRITE);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{co\_await}\ descriptor-\/>close();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ descriptor.reset();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{inline}\ std::string\ get\_remote\_host()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ descriptor-\/>get\_remote\_host();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{inline}\ uint16\_t\ get\_remote\_port()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ descriptor-\/>get\_remote\_port();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{class\ }tcp\_listener}
\DoxyCodeLine{\{}
\DoxyCodeLine{\textcolor{keyword}{private}:}
\DoxyCodeLine{\ \ \ \ std::shared\_ptr<detail::tcp\_listener\_descriptor>\ descriptor;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ tcp\_listener(std::shared\_ptr<detail::tcp\_listener\_descriptor>\ desc)\ :\ descriptor(std::move(desc))\ \{\}}
\DoxyCodeLine{\ \ \ \ \string~tcp\_listener()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (descriptor)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespacewebcraft_1_1async_aa32214c386ded164491af1d325b36e11}{fire\_and\_forget}}(descriptor-\/>close());}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ bind(\textcolor{keyword}{const}\ connection\_info\ \&info)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ descriptor-\/>bind(info);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{void}\ listen(\textcolor{keywordtype}{int}\ backlog)}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ descriptor-\/>listen(backlog);}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<tcp\_socket>}}\ accept()}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keyword}{co\_return}\ \textcolor{keyword}{co\_await}\ descriptor-\/>accept();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<tcp\_socket>}}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1socket_a482e358e1f53606e06109999484276b3}{make\_tcp\_socket}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ descriptor\ =\ \textcolor{keyword}{co\_await}\ detail::make\_tcp\_socket\_descriptor();}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{co\_return}\ tcp\_socket(std::move(descriptor));}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{classwebcraft_1_1async_1_1task}{task<tcp\_listener>}}\ \mbox{\hyperlink{namespacewebcraft_1_1async_1_1io_1_1socket_a861e0c806d177e378bae72a3cfb5f0e2}{make\_tcp\_listener}}()}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ descriptor\ =\ \textcolor{keyword}{co\_await}\ detail::make\_tcp\_listener\_descriptor();}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{co\_return}\ tcp\_listener(std::move(descriptor));}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_include_2webcraft_2async_2io_2README_autotoc_md39}{}\doxysection{\texorpdfstring{Implementation Details}{Implementation Details}}\label{md_include_2webcraft_2async_2io_2README_autotoc_md39}
The Web\+Craft framework implements platform-\/specific optimizations through\+:


\begin{DoxyItemize}
\item {\ttfamily webcraft\+::async\+::io\+::fs\+::detail\+::make\+\_\+file\+\_\+descriptor()} -\/ Creates platform-\/optimized file descriptors
\item {\ttfamily webcraft\+::async\+::io\+::socket\+::detail\+::make\+\_\+tcp\+\_\+socket\+\_\+descriptor()} -\/ Creates platform-\/optimized TCP socket descriptors ~\newline

\item {\ttfamily webcraft\+::async\+::io\+::socket\+::detail\+::make\+\_\+tcp\+\_\+listener\+\_\+descriptor()} -\/ Creates platform-\/optimized TCP listener descriptors
\end{DoxyItemize}

All functions return {\ttfamily std\+::shared\+\_\+ptr} to the appropriate descriptor types, providing automatic resource management and platform abstraction. 